{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\arnap\\\\portfolio\\\\src\\\\components\\\\SliderPuzzle.js\",\n  _s = $RefreshSig$();\nimport { useState } from 'react';\nimport './SliderPuzzle.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function SliderPuzzle() {\n  _s();\n  const [boardSize, setBoardSize] = useState(3); //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([[startingSquares], [null]]);\n  const [status, setStatus] = useState(null);\n  const [highScore, setHighScore] = useState(0);\n  // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n  // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n  function Square({\n    value,\n    onSquareClick\n  }) {\n    return /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"square\",\n      onClick: onSquareClick,\n      children: value\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 7\n    }, this);\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({\n    highScore,\n    currentScore\n  }) => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: overlayStyle,\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"You Win!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"High Score: \", highScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 35,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Your Score: \", currentScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 36,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 9\n    }, this);\n  };\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)',\n    // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n  function Board(isPlayer) {\n    let boardSize = Math.sqrt(playerSquares.length);\n    function handleClick(i, isPlayer) {\n      if (calculateWinner(playerSquares) || !isMovable(i, playerSquares) || !isPlayer) {\n        return;\n      }\n\n      //     clickSound.play();\n\n      setCount(count + 1);\n      const currentScore = count + 1;\n\n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n      if (calculateWinner(nextPlayerSquares)) {\n        if (highScore == 0) {\n          setHighScore(currentScore);\n        } else if (currentScore < highScore) {\n          setHighScore(currentScore);\n        }\n      }\n      return;\n    }\n\n    //function botMakesMove(){\n\n    // console.log(\"exploredNodes\", exploredNodes)\n    //let frontier = [exploredNodes[0].slice()];\n\n    // console.log(\"frontier at move start\", frontier);\n\n    // let explored = exploredNodes.slice();\n    //   let destination = [];\n\n    // explore every node for x layers and pick the best\n    // node based on manhattanSquares, then trace back that\n    // node to the parent node at the level of the next move\n    // then make the move\n\n    //for(let i = 1; i <= 2; i++){\n    //frontier = explore(frontier, explored, count + i);\n    //}\n\n    //console.log(\"frontier before sort\", frontier);\n\n    //      frontier = sortByCost(frontier);\n    //add the first element to the explored list\n\n    //console.log(\"frontier after sort\", frontier);\n\n    //    destination = frontier[0];\n\n    //  let nextNode = null;\n\n    //console.log(\"botSquares\", botSquares);\n    //console.log(\"explored[0][0]\", explored[0][0]);\n\n    //console.log(\"destination\", destination);\n    //console.log(\"destination 1\", destination[1]);\n\n    /* for(let i = destination[1]; i > explored[0][1] + 1; i--){\n      console.log(\"destination\", destination);                                         \n      nextNode = destination[2];  //gets the previous board to the desination     \n      console.log(\"nextNode\", nextNode); \n      destination = nextNode;     //and repeats til it's making only 1 move\n    }\n     exploredNodes.unshift(nextNode);\n     return nextNode[0];\n    old version -- randomly chooses tile to move\n    let moveFound = false;\n    let index = null;\n     while(!moveFound){\n      index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n      if(isMovable(index, botSquares)){\n        let nextSquares = botSquares.slice();\n        nextSquares[freeSquare(botSquares)] = botSquares[index];\n        nextSquares[index] = null;\n        setBotSquares(nextSquares);\n        moveFound = true;\n        return nextSquares;\n      }\n    }\n    */\n  }\n  const renderBoard = () => {\n    const board = [];\n    for (let i = 0; i < boardSize; i++) {\n      const row = [];\n      for (let j = 0; j < boardSize; j++) {\n        const index = boardSize * i + j;\n        row.push(/*#__PURE__*/_jsxDEV(Square, {\n          value: playerSquares[index],\n          onSquareClick: () => handleClick(index, isPlayer)\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 167,\n          columnNumber: 13\n        }, this));\n      }\n      board.push(/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"board-row\",\n        children: row\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 175,\n        columnNumber: 11\n      }, this));\n    }\n\n    //version 2 stuff\n    /* \n    if(isPlayer){\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index, isPlayer)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n      }\n    }\n    else{\n      console.log(\"botSquares\", botSquares);\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={botSquares[index]} \n              onSquareClick={() => handleClick(index)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n      }\n    }\n    */\n\n    return board;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"slide-puzzle-board\",\n    children: [renderBoard(), calculateWinner(playerSquares) && /*#__PURE__*/_jsxDEV(Overlay, {\n      highScore: highScore,\n      currentScore: count\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 226,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 224,\n    columnNumber: 13\n  }, this);\n}\n_s(SliderPuzzle, \"KYoqtXFlLocuDXsMHGsMLk2F0hQ=\");\n_c = SliderPuzzle;\nconst handleSizeChange = event => {\n  let newBoardSize = Number(event.target.value);\n  if (newBoardSize > 10 || newBoardSize < 2) {\n    setStatus(\"Please choose a size between 2 and 10!\");\n  } else {\n    restart();\n    setBoardSize(newBoardSize);\n    setStatus(null);\n    let newSquares = initialSetup(newBoardSize);\n    setPlayerSquares(newSquares);\n    // setBotSquares(newSquares);\n    setHistory([[newSquares], [null]]);\n  }\n};\nfunction undo() {\n  if (calculateWinner(playerSquares)) {\n    setStatus(null);\n  }\n  if (history[0].length > 1) {\n    console.log(\"undo\");\n    const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n    setHistory(lastHistory);\n    setCount(count - 1);\n    setPlayerSquares(lastHistory[0][count - 1]);\n    //  setBotSquares(lastHistory[1][count - 1]);\n  } else {\n    setStatus(\"No moves to undo!\");\n  }\n}\nfunction newShuffle() {\n  console.log(\"shuffle\");\n  restart();\n  shuffle(playerSquares);\n  setPlayerSquares(playerSquares);\n  //  setBotSquares(playerSquares);\n  setHistory([[playerSquares], [playerSquares]]);\n}\nfunction restart() {\n  console.log(\"restart\");\n  while (history[0].length > 1) {\n    history[0].pop();\n    history[1].pop();\n  }\n  setHistory([history[0], history[0]]);\n  setPlayerSquares(history[0][0]);\n  //    setBotSquares(history[1][0]);\n  setCount(0);\n  setStatus(null);\n}\n\n//this goes under Board(true) for version 2 -- <>{Board(false)}</>\n/*return(\n  <>\n    <input className='input' type=\"number\" defaultValue={boardSize} \n    onChange={handleSizeChange} min=\"2\" max=\"10\"/>\n     <div className=\"status\">{status}</div> \n    <div className=\"count\">Moves: {count}</div>\n    <div>\n        <>{Board(true)}</>\n    </div>\n    <div>\n      <button className=\"button\" onClick={() => undo()}>{\"Undo\"}</button>\n      <button className=\"button\" onClick={() => restart()}>{\"Restart\"}</button>\n    </div>\n    <button className=\"button\" onClick={() => newShuffle()}>{\"Shuffle\"}</button>\n  </>\n)\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n let explored = exploredNodesCopy.slice();\n //using startingLength keeps it constant, frontier is added to within the loop\nlet startingLength = frontier.length;\nfor(let j = 0; j < startingLength; j++){ \n   let squaresToBeExplored = frontier[j][0].slice();\n  //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n  let movableSquares = findMovableSquares(squaresToBeExplored);\n   for(let i = 0; i < movableSquares.length; i++){\n     let nextSquares = squaresToBeExplored.slice();\n    nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n    nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n     //special case for first move\n    if(frontier[0][2] == null){\n      console.log(\"this should only ever print once\");\n      frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n    } else if(!hasBeenExplored(nextSquares, explored)){\n        console.log(\"this node has not been explored\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n    }\n      //else => it has been explored so we dont add it\n  }\n   explored.push(frontier[j]);\n }\n //unlike above loop we need the final index to be variable \n//as we remove items or we will go out of bounds\nfor(let k = 0; k < frontier.length; k++){\n  if(frontier[k][1] < stepCost){\n    frontier.splice(k, 1);\n    k--;  //this accounts for the removal making sure to check the same index agian \n  }\n}\n console.log(\"frontier in explore loop\", frontier);\n return frontier;\n}\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n //sort the frontier by prioritizing manhattan distances comnbined with count\nlet scores = [];\nlet manhattanDistances = null;\nlet nodesToExplore = frontierCopy.slice();\n for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n  manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n  scores.push(manhattanDistances); // + frontierCopy[i][1]\n}\n //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n   if(scores[i] > scores[i + 1]){\n    //swap the elements in the frontiers AND the corresponding scores\n    let temp1 = scores[i];\n    let temp2 = nodesToExplore[i];\n //  console.log(\"temp2\", temp2);\n   scores[i] = scores[i + 1];\n  scores[i + 1] = temp1;\n   //console.log(i);\n   //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n   nodesToExplore[i] = nodesToExplore[i + 1];\n  nodesToExplore[i + 1] = temp2;\n     \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n//  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n  \n    //restarts the loop at 0 to start the check over again \n    //each time a change is made\n    i = -1;\n  }\n }\n// console.log(\"scores after sort\", scores);\n// console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n return nodesToExplore;\n}\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n for (let i = 0; i < exploredNodes.length; i++){\n   console.log(\"squares\", squares);\n  console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n   if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n    return true;\n  }\n  return false;\n}\n}\nfunction getManhattanDistances(squares){\n //note: the square with value 1 is index 0 in \"squares\"\nlet boardSize = Math.sqrt(squares.length);\nlet manhattanDistances = [];\n for (let i = 0; i < squares.length; i++){\n  let j = squares[i] - 1;\n  if(squares[i] == null){\n    j = squares.length - 1;\n  }\n   let startingRow = [Math.floor(i / boardSize)]\n  let startingCol = [i % boardSize]\n  let destinationRow = [Math.floor( j / boardSize)]\n  let destinationCol = [ j % boardSize]\n   let colDistance = Math.abs(destinationCol - startingCol);\n  let rowDistance = Math.abs(destinationRow - startingRow);\n   manhattanDistances.push(colDistance + rowDistance);\n }\n// console.log(\"manhattanDistances\", manhattanDistances);\nlet sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n// console.log(\"sum\", sum);\n return sum;\n}*/\n\nfunction freeSquare(squares) {\n  return findValue(squares, null);\n}\nfunction findValue(squares, value) {\n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for (let i = 0; i < squares.length; i++) {\n    if (squares[i] == value) position = i;\n  }\n  return position;\n}\nfunction initialSetup(boardSize) {\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++) {\n    //populate 1 -> 1-n\n    values.push(i);\n  }\n  values.push(null); //adds null instead of last number for free square\n  shuffle(values);\n  return values;\n}\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    let copy = values[currentIndex];\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n  if (!isSolvable(values)) {\n    shuffle(values);\n  }\n}\nfunction isSolvable(values) {\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0;\n  let rowMajorOrder = [];\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      rowMajorOrder.push(values[i]);\n    } else {\n      rowOfFreeSquare = Math.floor(i / boardSize);\n    }\n  }\n\n  //counts inversions\n  for (let i = 0; i < rowMajorOrder.length; i++) {\n    for (let j = i + 1; j < rowMajorOrder.length; j++) {\n      if (rowMajorOrder[i] > rowMajorOrder[j]) {\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0) {\n    return true;\n  } else if (boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isMovable(position, squares) {\n  let movable = findMovableSquares(squares);\n  for (let i = 0; i < movable.length; i++) {\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction findMovableSquares(squares) {\n  //setup table for movable square recognizing\n  let table = [];\n  let boardSize = Math.sqrt(squares.length);\n  for (let i = 0; i < boardSize; i++) {\n    let row = [];\n    for (let j = 0; j < boardSize; j++) {\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row);\n  }\n  let i = freeSquare(squares);\n  let column = i % boardSize;\n  let row = 0;\n  while (i >= boardSize) {\n    row++;\n    i = i - boardSize;\n  }\n\n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if (column + 1 != boardSize) {\n    movableSquares.push(table[row][column + 1]);\n  }\n  if (column - 1 != -1) {\n    movableSquares.push(table[row][column - 1]);\n  }\n  if (row + 1 != boardSize) {\n    movableSquares.push(table[row + 1][column]);\n  }\n  if (row - 1 != -1) {\n    movableSquares.push(table[row - 1][column]);\n  }\n  return movableSquares;\n}\nfunction calculateWinner(squares) {\n  const winnerCheck = new Array(squares.length - 1).fill(-1);\n  let squaresCopy = squares.slice(0);\n  for (let i = 0; i < squares.length - 1; i++) {\n    if (squaresCopy[i] == i + 1) {\n      squaresCopy[i] = -1;\n    }\n  }\n  for (let i = 0; i < squares.length - 1; i++) {\n    if (squaresCopy[i] !== winnerCheck[i]) return false;\n  }\n  return true;\n}\nvar _c;\n$RefreshReg$(_c, \"SliderPuzzle\");","map":{"version":3,"names":["useState","jsxDEV","_jsxDEV","SliderPuzzle","_s","boardSize","setBoardSize","count","setCount","startingSquares","initialSetup","playerSquares","setPlayerSquares","history","setHistory","status","setStatus","highScore","setHighScore","clickSound","Audio","Square","value","onSquareClick","className","onClick","children","fileName","_jsxFileName","lineNumber","columnNumber","console","log","Overlay","currentScore","style","overlayStyle","position","top","left","width","height","backgroundColor","color","display","flexDirection","justifyContent","alignItems","zIndex","Board","isPlayer","Math","sqrt","length","handleClick","i","calculateWinner","isMovable","nextPlayerSquares","slice","freeSquare","push","renderBoard","board","row","j","index","_c","handleSizeChange","event","newBoardSize","Number","target","restart","newSquares","undo","lastHistory","newShuffle","shuffle","pop","squares","findValue","values","currentIndex","randomIndex","floor","random","copy","isSolvable","inversions","rowMajorOrder","rowOfFreeSquare","movable","findMovableSquares","table","column","movableSquares","winnerCheck","Array","fill","squaresCopy","$RefreshReg$"],"sources":["C:/Users/arnap/portfolio/src/components/SliderPuzzle.js"],"sourcesContent":["import { useState } from 'react';\nimport './SliderPuzzle.css';\n\nexport default function SliderPuzzle() {\n\n  const [boardSize, setBoardSize] = useState(3);  //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([ [ startingSquares ], [ null ] ]);\n  const[status, setStatus] = useState(null);\n  const[highScore, setHighScore] = useState(0);\n // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n\n  function Square({ value, onSquareClick }) {\n    return (\n      <button className=\"square\" onClick={onSquareClick}>\n        {value}\n      </button>\n    );\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({ highScore, currentScore }) => {\n    return (\n        <div style={overlayStyle}>\n            <h2>You Win!</h2>\n            <p>High Score: {highScore}</p>\n            <p>Your Score: {currentScore}</p>\n        </div>\n    );\n  };\n\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)', // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n\n  function Board(isPlayer) {\n\n    let boardSize = Math.sqrt(playerSquares.length);\n\n  function handleClick(i, isPlayer) {\n\n    if (calculateWinner(playerSquares) \n      || !isMovable(i, playerSquares)\n      || !isPlayer){\n      return;\n    }\n      \n //     clickSound.play();\n   \n  setCount(count + 1);\n      const currentScore = count + 1;\n      \n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n  \n      if(calculateWinner(nextPlayerSquares)){ \n        if (highScore == 0){ setHighScore(currentScore) }\n        else if(currentScore < highScore) { setHighScore(currentScore) }\n      }\n\n      return;\n\n    }\n\n    //function botMakesMove(){\n\n     // console.log(\"exploredNodes\", exploredNodes)\n      //let frontier = [exploredNodes[0].slice()];\n\n     // console.log(\"frontier at move start\", frontier);\n\n     // let explored = exploredNodes.slice();\n   //   let destination = [];\n\n      // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n\n      //for(let i = 1; i <= 2; i++){\n        //frontier = explore(frontier, explored, count + i);\n      //}\n    \n      //console.log(\"frontier before sort\", frontier);\n\n//      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n      \n      //console.log(\"frontier after sort\", frontier);\n\n  //    destination = frontier[0];\n\n    //  let nextNode = null;\n\n      //console.log(\"botSquares\", botSquares);\n      //console.log(\"explored[0][0]\", explored[0][0]);\n\n      //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n\n      /* for(let i = destination[1]; i > explored[0][1] + 1; i--){\n        console.log(\"destination\", destination);                                         \n        nextNode = destination[2];  //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode); \n        destination = nextNode;     //and repeats til it's making only 1 move\n      }\n\n      exploredNodes.unshift(nextNode);\n\n      return nextNode[0];\n      old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n\n      while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */\n    }\n\n    const renderBoard = () => {\n      \n      const board = [];\n\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index, isPlayer)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n      }\n\n      //version 2 stuff\n      /* \n      if(isPlayer){\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={playerSquares[index]} \n                onSquareClick={() => handleClick(index, isPlayer)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */\n      \n      return board;\n    \n    }\n   \n    return (<div className=\"slide-puzzle-board\">{renderBoard()}\n    {calculateWinner(playerSquares) && \n    <Overlay highScore={highScore} currentScore={count} />}\n    </div>);\n  }\n\n  const handleSizeChange = (event) => {\n    let newBoardSize = Number(event.target.value)\n    if(newBoardSize > 10 || newBoardSize < 2){\n      setStatus(\"Please choose a size between 2 and 10!\");\n    }\n    else{\n      restart();\n      setBoardSize(newBoardSize);\n      setStatus(null);\n      let newSquares = initialSetup(newBoardSize);\n      setPlayerSquares(newSquares);\n     // setBotSquares(newSquares);\n      setHistory([[newSquares],[null]]);\n    }\n  };\n  \n  function undo() {\n    if(calculateWinner(playerSquares)){ setStatus(null); }\n    if(history[0].length > 1){\n      console.log(\"undo\");\n      const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n      setHistory(lastHistory);\n      setCount(count - 1);\n      setPlayerSquares(lastHistory[0][count - 1]);\n    //  setBotSquares(lastHistory[1][count - 1]);\n      \n    } \n    else{setStatus(\"No moves to undo!\");}   \n  }\n  \n  function newShuffle(){\n    console.log(\"shuffle\");\n    restart();\n    shuffle(playerSquares);\n    setPlayerSquares(playerSquares);\n  //  setBotSquares(playerSquares);\n    setHistory([[playerSquares], [playerSquares]]);\n  }\n  \n  function restart(){\n    console.log(\"restart\");\n    while( history[0].length > 1 ){ \n      history[0].pop(); history[1].pop(); } \n    setHistory([history[0], history[0] ]);\n    setPlayerSquares(history[0][0]);\n//    setBotSquares(history[1][0]);\n    setCount(0);\n    setStatus(null);\n  }\n\n\n  //this goes under Board(true) for version 2 -- <>{Board(false)}</>\n  /*return(\n    <>\n      <input className='input' type=\"number\" defaultValue={boardSize} \n      onChange={handleSizeChange} min=\"2\" max=\"10\"/>\n\n      <div className=\"status\">{status}</div> \n      <div className=\"count\">Moves: {count}</div>\n      <div>\n          <>{Board(true)}</>\n      </div>\n      <div>\n        <button className=\"button\" onClick={() => undo()}>{\"Undo\"}</button>\n        <button className=\"button\" onClick={() => restart()}>{\"Restart\"}</button>\n      </div>\n      <button className=\"button\" onClick={() => newShuffle()}>{\"Shuffle\"}</button>\n    </>\n  )\n\n\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for(let j = 0; j < startingLength; j++){ \n\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n\n    for(let i = 0; i < movableSquares.length; i++){\n\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if(frontier[0][2] == null){\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if(!hasBeenExplored(nextSquares, explored)){\n          console.log(\"this node has not been explored\");\n          frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n        //else => it has been explored so we dont add it\n    }\n\n    explored.push(frontier[j]);\n\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for(let k = 0; k < frontier.length; k++){\n    if(frontier[k][1] < stepCost){\n      frontier.splice(k, 1);\n      k--;  //this accounts for the removal making sure to check the same index agian \n    }\n  }\n\n  console.log(\"frontier in explore loop\", frontier);\n\n  return frontier;\n\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n\n  for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n\n    if(scores[i] > scores[i + 1]){\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n  //  console.log(\"temp2\", temp2);\n\n    scores[i] = scores[i + 1];\n    scores[i + 1] = temp1;\n\n    //console.log(i);\n\n    //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n    //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n    nodesToExplore[i] = nodesToExplore[i + 1];\n    nodesToExplore[i + 1] = temp2;\n\n      \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n    \n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n\n  }\n\n // console.log(\"scores after sort\", scores);\n // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n\n  for (let i = 0; i < exploredNodes.length; i++){\n\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n\n    if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n      return true;\n    }\n    return false;\n  }\n\n}\n\nfunction getManhattanDistances(squares){\n\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n\n  for (let i = 0; i < squares.length; i++){\n    let j = squares[i] - 1;\n    if(squares[i] == null){\n      j = squares.length - 1;\n    }\n\n    let startingRow = [Math.floor(i / boardSize)]\n    let startingCol = [i % boardSize]\n    let destinationRow = [Math.floor( j / boardSize)]\n    let destinationCol = [ j % boardSize]\n\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n\n    manhattanDistances.push(colDistance + rowDistance);\n\n  }\n\n // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n // console.log(\"sum\", sum);\n\n  return sum;\n\n}*/\n\nfunction freeSquare(squares){\n  return findValue(squares, null);\n}\n\nfunction findValue(squares, value){\n  \n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for(let i = 0; i < squares.length; i++){\n    if(squares[i] == value)\n      position = i;\n  }\n  return position;\n}\n\nfunction initialSetup(boardSize){\n\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++){   //populate 1 -> 1-n\n    values.push(i)           \n  }\n  values.push(null);           //adds null instead of last number for free square\n  shuffle(values);          \n  return values;\n\n}\n\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    let copy = values[currentIndex]\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n\n  if(!isSolvable(values)){shuffle(values);}\n\n}\n\nfunction isSolvable(values){\n\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0\n  let rowMajorOrder = []\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for(let i = 0; i < values.length; i++){\n    if(values[i] !== null){\n      rowMajorOrder.push(values[i]);\n    }\n    else{ \n      rowOfFreeSquare = Math.floor(i/ boardSize)\n    }\n  }\n\n  //counts inversions\n  for(let i = 0; i < rowMajorOrder.length; i++){\n    for(let j = i + 1; j < rowMajorOrder.length; j++){\n      if(rowMajorOrder[i] > rowMajorOrder[j]){\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0){return true} \n  else if( boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1){return true}\n  else{return false}\n\n}\n\nfunction isMovable(position, squares){\n\n  let movable = findMovableSquares(squares);\n  for(let i = 0; i < movable.length ; i++){\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction findMovableSquares(squares){\n\n  //setup table for movable square recognizing\n  let table = []\n  let boardSize = Math.sqrt(squares.length);\n\n  for (let i = 0; i < boardSize; i++){\n    let row = []\n    for (let j = 0; j < boardSize; j++){\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row)\n  }\n\n  let i = freeSquare(squares);\n  let column = i % boardSize; \n  let row = 0;\n  \n  while(i >= boardSize){\n    row++;\n    i = i - boardSize;\n  }\n  \n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if(column + 1 != boardSize){movableSquares.push(table[row][column + 1])}\n  if(column - 1 != -1){movableSquares.push(table[row][column - 1])}\n  if(row + 1 != boardSize){movableSquares.push(table[row + 1][column])}\n  if(row - 1 != -1){movableSquares.push(table[row - 1][column])}\n\n  return movableSquares;\n\n}\n\nfunction calculateWinner(squares) {\n\n   const winnerCheck = new Array(squares.length - 1).fill(-1);\n   let squaresCopy = squares.slice(0);\n \n   for (let i = 0; i < squares.length - 1; i++) {\n     if(squaresCopy[i] == i + 1){\n       squaresCopy[i] = -1\n     }\n   }\n \n   for(let i = 0; i < squares.length - 1; i++){\n     if (squaresCopy[i] !== winnerCheck[i]) return false;\n   }\n   return true;\n }\n"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAgDA,SAAS4C,UAAUA,CAACoB,OAAO,EAAC;EAC1B,OAAOC,SAAS,CAACD,OAAO,EAAE,IAAI,CAAC;AACjC;AAEA,SAASC,SAASA,CAACD,OAAO,EAAE1D,KAAK,EAAC;EAEhC;EACA;EACA,IAAIe,QAAQ,GAAG,IAAI;EACnB,KAAI,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,OAAO,CAAC3B,MAAM,EAAEE,CAAC,EAAE,EAAC;IACrC,IAAGyB,OAAO,CAACzB,CAAC,CAAC,IAAIjC,KAAK,EACpBe,QAAQ,GAAGkB,CAAC;EAChB;EACA,OAAOlB,QAAQ;AACjB;AAEA,SAAS3B,YAAYA,CAACL,SAAS,EAAC;EAE9B,IAAI6E,MAAM,GAAG,EAAE;EACf,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlD,SAAS,IAAI,CAAC,EAAEkD,CAAC,EAAE,EAAC;IAAI;IAC1C2B,MAAM,CAACrB,IAAI,CAACN,CAAC,CAAC;EAChB;EACA2B,MAAM,CAACrB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAW;EAC7BiB,OAAO,CAACI,MAAM,CAAC;EACf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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}