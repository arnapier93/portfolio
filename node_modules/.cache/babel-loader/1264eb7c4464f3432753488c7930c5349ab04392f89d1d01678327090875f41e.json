{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\arnap\\\\portfolio\\\\src\\\\components\\\\SliderPuzzle.js\",\n  _s = $RefreshSig$();\nimport { useState } from 'react';\nimport './SliderPuzzle.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function SliderPuzzle() {\n  _s();\n  const [boardSize, setBoardSize] = useState(3); //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([[startingSquares], [null]]);\n  const [status, setStatus] = useState(null);\n  const [highScore, setHighScore] = useState(0);\n  // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n  // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n  function Square({\n    value,\n    onSquareClick\n  }) {\n    return /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"square\",\n      onClick: onSquareClick,\n      children: value\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 7\n    }, this);\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({\n    highScore,\n    currentScore\n  }) => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: overlayStyle,\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"You Win!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"High Score: \", highScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 35,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Your Score: \", currentScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 36,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 9\n    }, this);\n  };\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)',\n    // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n  function Board(isPlayer) {\n    let boardSize = Math.sqrt(playerSquares.length);\n    function handleClick(i, isPlayer) {\n      if (calculateWinner(playerSquares) || !isMovable(i, playerSquares) || !isPlayer) {\n        return;\n      }\n\n      //     clickSound.play();\n\n      setCount(count + 1);\n      const currentScore = count + 1;\n\n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n      if (calculateWinner(nextPlayerSquares)) {\n        if (highScore == 0) {\n          setHighScore(currentScore);\n        } else if (currentScore < highScore) {\n          setHighScore(currentScore);\n        }\n      }\n      return;\n    }\n    function botMakesMove() {\n      console.log(\"exploredNodes\", exploredNodes);\n      let frontier = [exploredNodes[0].slice()];\n      console.log(\"frontier at move start\", frontier);\n      let explored = exploredNodes.slice();\n      let destination = [];\n\n      // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n\n      for (let i = 1; i <= 2; i++) {\n        frontier = explore(frontier, explored, count + i);\n      }\n\n      //console.log(\"frontier before sort\", frontier);\n\n      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n\n      //console.log(\"frontier after sort\", frontier);\n\n      destination = frontier[0];\n      let nextNode = null;\n      console.log(\"botSquares\", botSquares);\n      console.log(\"explored[0][0]\", explored[0][0]);\n\n      //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n\n      for (let i = destination[1]; i > explored[0][1] + 1; i--) {\n        console.log(\"destination\", destination);\n        nextNode = destination[2]; //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode);\n        destination = nextNode; //and repeats til it's making only 1 move\n      }\n      exploredNodes.unshift(nextNode);\n      return nextNode[0];\n      /* old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n       while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */\n    }\n    const renderBoard = () => {\n      const board = [];\n      for (let i = 0; i < boardSize; i++) {\n        const row = [];\n        for (let j = 0; j < boardSize; j++) {\n          const index = boardSize * i + j;\n          row.push(/*#__PURE__*/_jsxDEV(Square, {\n            value: playerSquares[index],\n            onSquareClick: () => handleClick(index, isPlayer)\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 167,\n            columnNumber: 13\n          }, this));\n        }\n        board.push(/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"board-row\",\n          children: row\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 11\n        }, this));\n      }\n\n      //version 2 stuff\n      /* \n      if(isPlayer){\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={playerSquares[index]} \n                onSquareClick={() => handleClick(index, isPlayer)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */\n\n      return board;\n    };\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"slide-puzzle-board\",\n      children: [renderBoard(), calculateWinner(playerSquares) && /*#__PURE__*/_jsxDEV(Overlay, {\n        highScore: highScore,\n        currentScore: count\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 226,\n        columnNumber: 5\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 13\n    }, this);\n  }\n  const handleSizeChange = event => {\n    let newBoardSize = Number(event.target.value);\n    if (newBoardSize > 10 || newBoardSize < 2) {\n      setStatus(\"Please choose a size between 2 and 10!\");\n    } else {\n      restart();\n      setBoardSize(newBoardSize);\n      setStatus(null);\n      let newSquares = initialSetup(newBoardSize);\n      setPlayerSquares(newSquares);\n      // setBotSquares(newSquares);\n      setHistory([[newSquares], [null]]);\n    }\n  };\n  function undo() {\n    if (calculateWinner(playerSquares)) {\n      setStatus(null);\n    }\n    if (history[0].length > 1) {\n      console.log(\"undo\");\n      const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n      setHistory(lastHistory);\n      setCount(count - 1);\n      setPlayerSquares(lastHistory[0][count - 1]);\n      //  setBotSquares(lastHistory[1][count - 1]);\n    } else {\n      setStatus(\"No moves to undo!\");\n    }\n  }\n  function newShuffle() {\n    console.log(\"shuffle\");\n    restart();\n    shuffle(playerSquares);\n    setPlayerSquares(playerSquares);\n    //  setBotSquares(playerSquares);\n    setHistory([[playerSquares], [playerSquares]]);\n  }\n  function restart() {\n    console.log(\"restart\");\n    while (history[0].length > 1) {\n      history[0].pop();\n      history[1].pop();\n    }\n    setHistory([history[0], history[0]]);\n    setPlayerSquares(history[0][0]);\n    //    setBotSquares(history[1][0]);\n    setCount(0);\n    setStatus(null);\n  }\n\n  //this goes under Board(true) for version 2 -- <>{Board(false)}</>\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      className: \"input\",\n      type: \"number\",\n      defaultValue: boardSize,\n      onChange: handleSizeChange,\n      min: \"2\",\n      max: \"10\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 285,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status\",\n      children: status\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 288,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"count\",\n      children: [\"Moves: \", count]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 289,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: Board(true)\n      }, void 0, false)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 290,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"button\",\n        onClick: () => undo(),\n        children: \"Undo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 294,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"button\",\n        onClick: () => restart(),\n        children: \"Restart\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 293,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"button\",\n      onClick: () => newShuffle(),\n      children: \"Shuffle\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}\n_s(SliderPuzzle, \"KYoqtXFlLocuDXsMHGsMLk2F0hQ=\");\n_c = SliderPuzzle;\nfunction explore(frontier, exploredNodesCopy, stepCost) {\n  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for (let j = 0; j < startingLength; j++) {\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n    for (let i = 0; i < movableSquares.length; i++) {\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if (frontier[0][2] == null) {\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if (!hasBeenExplored(nextSquares, explored)) {\n        console.log(\"this node has not been explored\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n      //else => it has been explored so we dont add it\n    }\n    explored.push(frontier[j]);\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for (let k = 0; k < frontier.length; k++) {\n    if (frontier[k][1] < stepCost) {\n      frontier.splice(k, 1);\n      k--; //this accounts for the removal making sure to check the same index agian \n    }\n  }\n  console.log(\"frontier in explore loop\", frontier);\n  return frontier;\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy) {\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n  for (let i = 0; i < nodesToExplore.length; i++) {\n    //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n  ////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++) {\n    //sorts frontier based on scores\n\n    if (scores[i] > scores[i + 1]) {\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n      //  console.log(\"temp2\", temp2);\n\n      scores[i] = scores[i + 1];\n      scores[i + 1] = temp1;\n\n      //console.log(i);\n\n      //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n      //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n      nodesToExplore[i] = nodesToExplore[i + 1];\n      nodesToExplore[i + 1] = temp2;\n\n      //    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n      //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n  }\n\n  // console.log(\"scores after sort\", scores);\n  // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes) {\n  for (let i = 0; i < exploredNodes.length; i++) {\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n    if (JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())) {\n      return true;\n    }\n    return false;\n  }\n}\nfunction getManhattanDistances(squares) {\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n  for (let i = 0; i < squares.length; i++) {\n    let j = squares[i] - 1;\n    if (squares[i] == null) {\n      j = squares.length - 1;\n    }\n    let startingRow = [Math.floor(i / boardSize)];\n    let startingCol = [i % boardSize];\n    let destinationRow = [Math.floor(j / boardSize)];\n    let destinationCol = [j % boardSize];\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n    manhattanDistances.push(colDistance + rowDistance);\n  }\n\n  // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n  // console.log(\"sum\", sum);\n\n  return sum;\n}\nfunction freeSquare(squares) {\n  return findValue(squares, null);\n}\nfunction findValue(squares, value) {\n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for (let i = 0; i < squares.length; i++) {\n    if (squares[i] == value) position = i;\n  }\n  return position;\n}\nfunction initialSetup(boardSize) {\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++) {\n    //populate 1 -> 1-n\n    values.push(i);\n  }\n  values.push(null); //adds null instead of last number for free square\n  shuffle(values);\n  return values;\n}\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    let copy = values[currentIndex];\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n  if (!isSolvable(values)) {\n    shuffle(values);\n  }\n}\nfunction isSolvable(values) {\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0;\n  let rowMajorOrder = [];\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      rowMajorOrder.push(values[i]);\n    } else {\n      rowOfFreeSquare = Math.floor(i / boardSize);\n    }\n  }\n\n  //counts inversions\n  for (let i = 0; i < rowMajorOrder.length; i++) {\n    for (let j = i + 1; j < rowMajorOrder.length; j++) {\n      if (rowMajorOrder[i] > rowMajorOrder[j]) {\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0) {\n    return true;\n  } else if (boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isMovable(position, squares) {\n  let movable = findMovableSquares(squares);\n  for (let i = 0; i < movable.length; i++) {\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction findMovableSquares(squares) {\n  //setup table for movable square recognizing\n  let table = [];\n  let boardSize = Math.sqrt(squares.length);\n  for (let i = 0; i < boardSize; i++) {\n    let row = [];\n    for (let j = 0; j < boardSize; j++) {\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row);\n  }\n  let i = freeSquare(squares);\n  let column = i % boardSize;\n  let row = 0;\n  while (i >= boardSize) {\n    row++;\n    i = i - boardSize;\n  }\n\n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if (column + 1 != boardSize) {\n    movableSquares.push(table[row][column + 1]);\n  }\n  if (column - 1 != -1) {\n    movableSquares.push(table[row][column - 1]);\n  }\n  if (row + 1 != boardSize) {\n    movableSquares.push(table[row + 1][column]);\n  }\n  if (row - 1 != -1) {\n    movableSquares.push(table[row - 1][column]);\n  }\n  return movableSquares;\n}\nfunction calculateWinner(squares) {\n  const winnerCheck = new Array(squares.length - 1).fill(-1);\n  let squaresCopy = squares.slice(0);\n  for (let i = 0; i < squares.length - 1; i++) {\n    if (squaresCopy[i] == i + 1) {\n      squaresCopy[i] = -1;\n    }\n  }\n  for (let i = 0; i < squares.length - 1; i++) {\n    if (squaresCopy[i] !== winnerCheck[i]) return false;\n  }\n  return true;\n}\nvar _c;\n$RefreshReg$(_c, \"SliderPuzzle\");","map":{"version":3,"names":["useState","jsxDEV","_jsxDEV","Fragment","_Fragment","SliderPuzzle","_s","boardSize","setBoardSize","count","setCount","startingSquares","initialSetup","playerSquares","setPlayerSquares","history","setHistory","status","setStatus","highScore","setHighScore","clickSound","Audio","Square","value","onSquareClick","className","onClick","children","fileName","_jsxFileName","lineNumber","columnNumber","console","log","Overlay","currentScore","style","overlayStyle","position","top","left","width","height","backgroundColor","color","display","flexDirection","justifyContent","alignItems","zIndex","Board","isPlayer","Math","sqrt","length","handleClick","i","calculateWinner","isMovable","nextPlayerSquares","slice","freeSquare","push","botMakesMove","exploredNodes","frontier","explored","destination","explore","sortByCost","nextNode","botSquares","unshift","renderBoard","board","row","j","index","handleSizeChange","event","newBoardSize","Number","target","restart","newSquares","undo","lastHistory","newShuffle","shuffle","pop","type","defaultValue","onChange","min","max","_c","exploredNodesCopy","stepCost","startingLength","squaresToBeExplored","movableSquares","findMovableSquares","nextSquares","findValue","getManhattanDistances","hasBeenExplored","k","splice","frontierCopy","scores","manhattanDistances","nodesToExplore","temp1","temp2","squares","JSON","stringify","startingRow","floor","startingCol","destinationRow","destinationCol","colDistance","abs","rowDistance","sum","reduce","accumulator","current","values","currentIndex","randomIndex","random","copy","isSolvable","inversions","rowMajorOrder","rowOfFreeSquare","movable","table","column","winnerCheck","Array","fill","squaresCopy","$RefreshReg$"],"sources":["C:/Users/arnap/portfolio/src/components/SliderPuzzle.js"],"sourcesContent":["import { useState } from 'react';\nimport './SliderPuzzle.css';\n\nexport default function SliderPuzzle() {\n\n  const [boardSize, setBoardSize] = useState(3);  //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([ [ startingSquares ], [ null ] ]);\n  const[status, setStatus] = useState(null);\n  const[highScore, setHighScore] = useState(0);\n // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n\n  function Square({ value, onSquareClick }) {\n    return (\n      <button className=\"square\" onClick={onSquareClick}>\n        {value}\n      </button>\n    );\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({ highScore, currentScore }) => {\n    return (\n        <div style={overlayStyle}>\n            <h2>You Win!</h2>\n            <p>High Score: {highScore}</p>\n            <p>Your Score: {currentScore}</p>\n        </div>\n    );\n  };\n\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)', // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n\n  function Board(isPlayer) {\n\n    let boardSize = Math.sqrt(playerSquares.length);\n\n    function handleClick(i, isPlayer) {\n\n      if (calculateWinner(playerSquares) \n        || !isMovable(i, playerSquares)\n        || !isPlayer){\n        return;\n      }\n      \n //     clickSound.play();\n   \n setCount(count + 1);\n      const currentScore = count + 1;\n      \n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n  \n      if(calculateWinner(nextPlayerSquares)){ \n        if (highScore == 0){ setHighScore(currentScore) }\n        else if(currentScore < highScore) { setHighScore(currentScore) }\n      }\n\n      return;\n\n    }\n\n    function botMakesMove(){\n\n      console.log(\"exploredNodes\", exploredNodes)\n      let frontier = [exploredNodes[0].slice()];\n\n      console.log(\"frontier at move start\", frontier);\n\n      let explored = exploredNodes.slice();\n      let destination = [];\n\n      // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n\n      for(let i = 1; i <= 2; i++){\n        frontier = explore(frontier, explored, count + i);\n      }\n    \n      //console.log(\"frontier before sort\", frontier);\n\n      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n      \n      //console.log(\"frontier after sort\", frontier);\n\n      destination = frontier[0];\n\n      let nextNode = null;\n\n      console.log(\"botSquares\", botSquares);\n      console.log(\"explored[0][0]\", explored[0][0]);\n\n      //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n\n      for(let i = destination[1]; i > explored[0][1] + 1; i--){\n        console.log(\"destination\", destination);                                         \n        nextNode = destination[2];  //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode); \n        destination = nextNode;     //and repeats til it's making only 1 move\n      }\n\n      exploredNodes.unshift(nextNode);\n\n      return nextNode[0];\n      /* old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n\n      while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */\n    }\n\n    const renderBoard = () => {\n      \n      const board = [];\n\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index, isPlayer)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n      }\n\n      //version 2 stuff\n      /* \n      if(isPlayer){\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={playerSquares[index]} \n                onSquareClick={() => handleClick(index, isPlayer)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */\n      \n      return board;\n    \n    }\n   \n    return (<div className=\"slide-puzzle-board\">{renderBoard()}\n    {calculateWinner(playerSquares) && \n    <Overlay highScore={highScore} currentScore={count} />}\n    </div>);\n  \n  }\n\n  const handleSizeChange = (event) => {\n    let newBoardSize = Number(event.target.value)\n    if(newBoardSize > 10 || newBoardSize < 2){\n      setStatus(\"Please choose a size between 2 and 10!\");\n    }\n    else{\n      restart();\n      setBoardSize(newBoardSize);\n      setStatus(null);\n      let newSquares = initialSetup(newBoardSize);\n      setPlayerSquares(newSquares);\n     // setBotSquares(newSquares);\n      setHistory([[newSquares],[null]]);\n    }\n  };\n  \n  function undo() {\n    if(calculateWinner(playerSquares)){ setStatus(null); }\n    if(history[0].length > 1){\n      console.log(\"undo\");\n      const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n      setHistory(lastHistory);\n      setCount(count - 1);\n      setPlayerSquares(lastHistory[0][count - 1]);\n    //  setBotSquares(lastHistory[1][count - 1]);\n      \n    } \n    else{setStatus(\"No moves to undo!\");}   \n  }\n  \n  function newShuffle(){\n    console.log(\"shuffle\");\n    restart();\n    shuffle(playerSquares);\n    setPlayerSquares(playerSquares);\n  //  setBotSquares(playerSquares);\n    setHistory([[playerSquares], [playerSquares]]);\n  }\n  \n  function restart(){\n    console.log(\"restart\");\n    while( history[0].length > 1 ){ \n      history[0].pop(); history[1].pop(); } \n    setHistory([history[0], history[0] ]);\n    setPlayerSquares(history[0][0]);\n//    setBotSquares(history[1][0]);\n    setCount(0);\n    setStatus(null);\n  }\n\n\n  //this goes under Board(true) for version 2 -- <>{Board(false)}</>\n  return(\n    <>\n      <input className='input' type=\"number\" defaultValue={boardSize} \n      onChange={handleSizeChange} min=\"2\" max=\"10\"/>\n\n      <div className=\"status\">{status}</div> \n      <div className=\"count\">Moves: {count}</div>\n      <div>\n          <>{Board(true)}</>\n      </div>\n      <div>\n        <button className=\"button\" onClick={() => undo()}>{\"Undo\"}</button>\n        <button className=\"button\" onClick={() => restart()}>{\"Restart\"}</button>\n      </div>\n      <button className=\"button\" onClick={() => newShuffle()}>{\"Shuffle\"}</button>\n    </>\n  )\n}\n\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for(let j = 0; j < startingLength; j++){ \n\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n\n    for(let i = 0; i < movableSquares.length; i++){\n\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if(frontier[0][2] == null){\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if(!hasBeenExplored(nextSquares, explored)){\n          console.log(\"this node has not been explored\");\n          frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n        //else => it has been explored so we dont add it\n    }\n\n    explored.push(frontier[j]);\n\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for(let k = 0; k < frontier.length; k++){\n    if(frontier[k][1] < stepCost){\n      frontier.splice(k, 1);\n      k--;  //this accounts for the removal making sure to check the same index agian \n    }\n  }\n\n  console.log(\"frontier in explore loop\", frontier);\n\n  return frontier;\n\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n\n  for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n\n    if(scores[i] > scores[i + 1]){\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n  //  console.log(\"temp2\", temp2);\n\n    scores[i] = scores[i + 1];\n    scores[i + 1] = temp1;\n\n    //console.log(i);\n\n    //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n    //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n    nodesToExplore[i] = nodesToExplore[i + 1];\n    nodesToExplore[i + 1] = temp2;\n\n      \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n    \n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n\n  }\n\n // console.log(\"scores after sort\", scores);\n // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n\n  for (let i = 0; i < exploredNodes.length; i++){\n\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n\n    if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n      return true;\n    }\n    return false;\n  }\n\n}\n\nfunction getManhattanDistances(squares){\n\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n\n  for (let i = 0; i < squares.length; i++){\n    let j = squares[i] - 1;\n    if(squares[i] == null){\n      j = squares.length - 1;\n    }\n\n    let startingRow = [Math.floor(i / boardSize)]\n    let startingCol = [i % boardSize]\n    let destinationRow = [Math.floor( j / boardSize)]\n    let destinationCol = [ j % boardSize]\n\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n\n    manhattanDistances.push(colDistance + rowDistance);\n\n  }\n\n // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n // console.log(\"sum\", sum);\n\n  return sum;\n\n}\n\nfunction freeSquare(squares){\n  return findValue(squares, null);\n}\n\nfunction findValue(squares, value){\n  \n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for(let i = 0; i < squares.length; i++){\n    if(squares[i] == value)\n      position = i;\n  }\n  return position;\n}\n\nfunction initialSetup(boardSize){\n\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++){   //populate 1 -> 1-n\n    values.push(i)           \n  }\n  values.push(null);           //adds null instead of last number for free square\n  shuffle(values);          \n  return values;\n\n}\n\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    let copy = values[currentIndex]\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n\n  if(!isSolvable(values)){shuffle(values);}\n\n}\n\nfunction isSolvable(values){\n\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0\n  let rowMajorOrder = []\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for(let i = 0; i < values.length; i++){\n    if(values[i] !== null){\n      rowMajorOrder.push(values[i]);\n    }\n    else{ \n      rowOfFreeSquare = Math.floor(i/ boardSize)\n    }\n  }\n\n  //counts inversions\n  for(let i = 0; i < rowMajorOrder.length; i++){\n    for(let j = i + 1; j < rowMajorOrder.length; j++){\n      if(rowMajorOrder[i] > rowMajorOrder[j]){\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0){return true} \n  else if( boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1){return true}\n  else{return false}\n\n}\n\nfunction isMovable(position, squares){\n\n  let movable = findMovableSquares(squares);\n  for(let i = 0; i < movable.length ; i++){\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction findMovableSquares(squares){\n\n  //setup table for movable square recognizing\n  let table = []\n  let boardSize = Math.sqrt(squares.length);\n\n  for (let i = 0; i < boardSize; i++){\n    let row = []\n    for (let j = 0; j < boardSize; j++){\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row)\n  }\n\n  let i = freeSquare(squares);\n  let column = i % boardSize; \n  let row = 0;\n  \n  while(i >= boardSize){\n    row++;\n    i = i - boardSize;\n  }\n  \n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if(column + 1 != boardSize){movableSquares.push(table[row][column + 1])}\n  if(column - 1 != -1){movableSquares.push(table[row][column - 1])}\n  if(row + 1 != boardSize){movableSquares.push(table[row + 1][column])}\n  if(row - 1 != -1){movableSquares.push(table[row - 1][column])}\n\n  return movableSquares;\n\n}\n\nfunction calculateWinner(squares) {\n\n   const winnerCheck = new Array(squares.length - 1).fill(-1);\n   let squaresCopy = squares.slice(0);\n \n   for (let i = 0; i < squares.length - 1; i++) {\n     if(squaresCopy[i] == i + 1){\n       squaresCopy[i] = -1\n     }\n   }\n \n   for(let i = 0; i < squares.length - 1; i++){\n     if (squaresCopy[i] !== winnerCheck[i]) return false;\n   }\n   return true;\n }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}