{"ast":null,"code":"import{useState}from'react';import\"./SliderPuzzle.css\";import{jsx as _jsx,jsxs as _jsxs,Fragment as _Fragment}from\"react/jsx-runtime\";const SliderPuzzle=()=>{const[boardSize,setBoardSize]=useState(3);//defaults to 3\nconst[count,setCount]=useState(0);const startingSquares=initialSetup(boardSize);const[playerSquares,setPlayerSquares]=useState(startingSquares);//const [botSquares, setBotSquares] = useState(startingSquares);\nconst[history,setHistory]=useState([[startingSquares],[null]]);const[status,setStatus]=useState(null);const[highScore,setHighScore]=useState(0);// const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n// const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\nconst clickSound=new Audio('../click.ogg');function Square(_ref){let{value,onSquareClick}=_ref;return/*#__PURE__*/_jsx(\"button\",{className:\"square\",onClick:onSquareClick,children:value});}//console.log(\"history\", history);\n//console.log(\"frontier\", frontier);\nconsole.log(\"count\",count);//console.log(\"exlporeNodes\", exploredNodes);\nconst Overlay=_ref2=>{let{highScore,currentScore}=_ref2;return/*#__PURE__*/_jsxs(\"div\",{style:overlayStyle,children:[/*#__PURE__*/_jsx(\"h2\",{children:\"You Win!\"}),/*#__PURE__*/_jsxs(\"p\",{children:[\"High Score: \",highScore]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Your Score: \",currentScore]})]});};const overlayStyle={position:'absolute',top:0,left:0,width:'100%',height:'100%',backgroundColor:'rgba(0, 0, 0, 0.7)',// Semi-transparent black\ncolor:'white',display:'flex',flexDirection:'column',justifyContent:'center',alignItems:'center',zIndex:1000};function Board(){let boardSize=Math.sqrt(playerSquares.length);function handleClick(i){//if the player clicks after winning or on an unmovable tile nothing happens\nif(calculateWinner(playerSquares)||!isMovable(i,playerSquares)){return;}//play an error noise\nclickSound.play();setCount(count+1);const currentScore=count+1;//let nextBotSquares = botMakesMove();\n//setBotSquares(nextBotSquares);      \nlet nextPlayerSquares=playerSquares.slice();nextPlayerSquares[freeSquare(playerSquares)]=playerSquares[i];nextPlayerSquares[i]=null;setPlayerSquares(nextPlayerSquares);history[0].push(nextPlayerSquares);history[1].push([null]);setHistory([[...history[0]],[...history[1]]]);if(calculateWinner(nextPlayerSquares)){if(highScore==0){setHighScore(currentScore);}else if(currentScore<highScore){setHighScore(currentScore);}}return;}/*function botMakesMove(){\n\n     // console.log(\"exploredNodes\", exploredNodes)\n      //let frontier = [exploredNodes[0].slice()];\n\n     // console.log(\"frontier at move start\", frontier);\n\n     // let explored = exploredNodes.slice();\n   //   let destination = [];\n\n      // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n\n      //for(let i = 1; i <= 2; i++){\n        //frontier = explore(frontier, explored, count + i);\n      //}\n    \n      //console.log(\"frontier before sort\", frontier);\n\n//      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n      \n      //console.log(\"frontier after sort\", frontier);\n\n  //    destination = frontier[0];\n\n    //  let nextNode = null;\n\n      //console.log(\"botSquares\", botSquares);\n      //console.log(\"explored[0][0]\", explored[0][0]);\n\n      //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n\n      for(let i = destination[1]; i > explored[0][1] + 1; i--){\n        console.log(\"destination\", destination);                                         \n        nextNode = destination[2];  //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode); \n        destination = nextNode;     //and repeats til it's making only 1 move\n      }\n\n      exploredNodes.unshift(nextNode);\n\n      return nextNode[0];\n      old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n\n      while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */const renderBoard=()=>{const board=[];for(let i=0;i<boardSize;i++){const row=[];for(let j=0;j<boardSize;j++){const index=boardSize*i+j;row.push(/*#__PURE__*/_jsx(Square,{value:playerSquares[index],onSquareClick:()=>handleClick(index)},index));}board.push(/*#__PURE__*/_jsx(\"div\",{className:\"board-row\",children:row},i));}//if(isPlayer){\nfor(let i=0;i<boardSize;i++){const row=[];for(let j=0;j<boardSize;j++){const index=boardSize*i+j;row.push(/*#__PURE__*/_jsx(Square,{value:playerSquares[index],onSquareClick:()=>handleClick(index)},index));}board.push(/*#__PURE__*/_jsx(\"div\",{className:\"board-row\",children:row},i));//}\n}//Version 2 stuff\n/*\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */return board;};return/*#__PURE__*/_jsxs(\"div\",{className:\"slide-puzzle-board\",children:[renderBoard(),calculateWinner(playerSquares)&&/*#__PURE__*/_jsx(Overlay,{highScore:highScore,currentScore:count})]});}const handleSizeChange=event=>{let newBoardSize=Number(event.target.value);if(newBoardSize>10||newBoardSize<2){setStatus(\"Please choose a size between 2 and 10!\");}else{restart();setBoardSize(newBoardSize);setStatus(null);let newSquares=initialSetup(newBoardSize);setPlayerSquares(newSquares);// setBotSquares(newSquares);\nsetHistory([[newSquares],[null]]);}};function undo(){if(calculateWinner(playerSquares)){setStatus(null);}if(history[0].length>1){console.log(\"undo\");const lastHistory=[[...history[0].slice(0,count)],[...history[1].slice(0,count)]];setHistory(lastHistory);setCount(count-1);setPlayerSquares(lastHistory[0][count-1]);//  setBotSquares(lastHistory[1][count - 1]);  \n}else{setStatus(\"No moves to undo!\");}}function newShuffle(){console.log(\"shuffle\");restart();shuffle(playerSquares);setPlayerSquares(playerSquares);//  setBotSquares(playerSquares);\nsetHistory([[playerSquares],[playerSquares]]);}function restart(){console.log(\"restart\");while(history[0].length>1){history[0].pop();history[1].pop();}setHistory([history[0],history[0]]);setPlayerSquares(history[0][0]);//    setBotSquares(history[1][0]);\nsetCount(0);setStatus(null);}return/*#__PURE__*/_jsxs(\"div\",{className:\"slider-puzzle\",children:[/*#__PURE__*/_jsx(\"input\",{className:\"input\",type:\"number\",defaultValue:boardSize,onChange:handleSizeChange,min:\"2\",max:\"10\"}),/*#__PURE__*/_jsx(\"div\",{className:\"status\",children:status}),/*#__PURE__*/_jsxs(\"div\",{className:\"count\",children:[\"Moves: \",count]}),/*#__PURE__*/_jsx(\"div\",{children:/*#__PURE__*/_jsx(_Fragment,{children:Board()})}),/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"button\",{className:\"button\",onClick:()=>undo(),children:\"Undo\"}),/*#__PURE__*/_jsx(\"button\",{className:\"button\",onClick:()=>restart(),children:\"Restart\"})]}),/*#__PURE__*/_jsx(\"button\",{className:\"button\",onClick:()=>newShuffle(),children:\"Shuffle\"})]});};export default SliderPuzzle;/*\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for(let j = 0; j < startingLength; j++){ \n\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n\n    for(let i = 0; i < movableSquares.length; i++){\n\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if(frontier[0][2] == null){\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if(!hasBeenExplored(nextSquares, explored)){\n          console.log(\"this node has not been explored\");\n          frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n        //else => it has been explored so we dont add it\n    }\n\n    explored.push(frontier[j]);\n\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for(let k = 0; k < frontier.length; k++){\n    if(frontier[k][1] < stepCost){\n      frontier.splice(k, 1);\n      k--;  //this accounts for the removal making sure to check the same index agian \n    }\n  }\n\n  console.log(\"frontier in explore loop\", frontier);\n\n  return frontier;\n\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n\n  for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n\n    if(scores[i] > scores[i + 1]){\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n  //  console.log(\"temp2\", temp2);\n\n    scores[i] = scores[i + 1];\n    scores[i + 1] = temp1;\n\n    //console.log(i);\n\n    //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n    //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n    nodesToExplore[i] = nodesToExplore[i + 1];\n    nodesToExplore[i + 1] = temp2;\n\n      \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n    \n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n\n  }\n\n // console.log(\"scores after sort\", scores);\n // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n\n  for (let i = 0; i < exploredNodes.length; i++){\n\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n\n    if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n      return true;\n    }\n    return false;\n  }\n\n}\n\nfunction getManhattanDistances(squares){\n\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n\n  for (let i = 0; i < squares.length; i++){\n    let j = squares[i] - 1;\n    if(squares[i] == null){\n      j = squares.length - 1;\n    }\n\n    let startingRow = [Math.floor(i / boardSize)]\n    let startingCol = [i % boardSize]\n    let destinationRow = [Math.floor( j / boardSize)]\n    let destinationCol = [ j % boardSize]\n\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n\n    manhattanDistances.push(colDistance + rowDistance);\n\n  }\n\n // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n // console.log(\"sum\", sum);\n\n  return sum;\n\n}*/function freeSquare(squares){return findValue(squares,null);}function findValue(squares,value){//returns position in \"squares\" of the value\n//console.log(\"squares, value\", squares, value)\nlet position=null;for(let i=0;i<squares.length;i++){if(squares[i]==value)position=i;}return position;}function initialSetup(boardSize){let values=[];for(let i=1;i<boardSize**2;i++){//populate 1 -> 1-n\nvalues.push(i);}values.push(null);//adds null instead of last number for free square\nshuffle(values);return values;}function shuffle(values){let currentIndex=values.length;while(currentIndex!=0){let randomIndex=Math.floor(Math.random()*currentIndex);currentIndex--;let copy=values[currentIndex];values[currentIndex]=values[randomIndex];values[randomIndex]=copy;}if(!isSolvable(values)){shuffle(values);}}function isSolvable(values){//for odd numbered boardsizes the # of inversions in the\n//row major order must be even to be solvable\n//an inversion is any pair of tiles i and j where i > j \n//but i appears before j when considering the board in row-major order\n//for even numbered boardsizes it is only solvable if and only if the \n//number of inversions //plus// the row of the free square is odd.\n//values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n//solvable board for debugging 10 inversions\nlet inversions=0;let rowMajorOrder=[];let rowOfFreeSquare=-1;let boardSize=Math.sqrt(values.length);//removes the null\nfor(let i=0;i<values.length;i++){if(values[i]!==null){rowMajorOrder.push(values[i]);}else{rowOfFreeSquare=Math.floor(i/boardSize);}}//counts inversions\nfor(let i=0;i<rowMajorOrder.length;i++){for(let j=i+1;j<rowMajorOrder.length;j++){if(rowMajorOrder[i]>rowMajorOrder[j]){inversions++;}}}//check if its even or not\nif(boardSize%2==1&&inversions%2==0){return true;}else if(boardSize%2==0&&(inversions+rowOfFreeSquare)%2==1){return true;}else{return false;}}function isMovable(position,squares){let movable=findMovableSquares(squares);for(let i=0;i<movable.length;i++){if(movable[i]==squares[position]){return true;}}return false;}function findMovableSquares(squares){//setup table for movable square recognizing\nlet table=[];let boardSize=Math.sqrt(squares.length);for(let i=0;i<boardSize;i++){let row=[];for(let j=0;j<boardSize;j++){row.push(squares[boardSize*i+j]);}table.push(row);}let i=freeSquare(squares);let column=i%boardSize;let row=0;while(i>=boardSize){row++;i=i-boardSize;}//checks if the index is out of bounds and if not it adds that value to the list\nlet movableSquares=[];if(column+1!=boardSize){movableSquares.push(table[row][column+1]);}if(column-1!=-1){movableSquares.push(table[row][column-1]);}if(row+1!=boardSize){movableSquares.push(table[row+1][column]);}if(row-1!=-1){movableSquares.push(table[row-1][column]);}return movableSquares;}function calculateWinner(squares){const winnerCheck=new Array(squares.length-1).fill(-1);let squaresCopy=squares.slice(0);for(let i=0;i<squares.length-1;i++){if(squaresCopy[i]==i+1){squaresCopy[i]=-1;}}for(let i=0;i<squares.length-1;i++){if(squaresCopy[i]!==winnerCheck[i])return false;}return true;}","map":{"version":3,"names":["useState","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","SliderPuzzle","boardSize","setBoardSize","count","setCount","startingSquares","initialSetup","playerSquares","setPlayerSquares","history","setHistory","status","setStatus","highScore","setHighScore","clickSound","Audio","Square","_ref","value","onSquareClick","className","onClick","children","console","log","Overlay","_ref2","currentScore","style","overlayStyle","position","top","left","width","height","backgroundColor","color","display","flexDirection","justifyContent","alignItems","zIndex","Board","Math","sqrt","length","handleClick","i","calculateWinner","isMovable","play","nextPlayerSquares","slice","freeSquare","push","renderBoard","board","row","j","index","handleSizeChange","event","newBoardSize","Number","target","restart","newSquares","undo","lastHistory","newShuffle","shuffle","pop","type","defaultValue","onChange","min","max","squares","findValue","values","currentIndex","randomIndex","floor","random","copy","isSolvable","inversions","rowMajorOrder","rowOfFreeSquare","movable","findMovableSquares","table","column","movableSquares","winnerCheck","Array","fill","squaresCopy"],"sources":["C:/portfolio/src/components/SliderPuzzle.js"],"sourcesContent":["import { useState } from 'react';\nimport \"./SliderPuzzle.css\"\n\nconst SliderPuzzle = () => {\n\n  const [boardSize, setBoardSize] = useState(3);  //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([ [ startingSquares ], [ null ] ]);\n  const[status, setStatus] = useState(null);\n  const[highScore, setHighScore] = useState(0);\n // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n\n  function Square({ value, onSquareClick }) {\n    return (\n      <button className=\"square\" onClick={onSquareClick}>\n        {value}\n      </button>\n    );\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({ highScore, currentScore }) => {\n    return (\n        <div style={overlayStyle}>\n            <h2>You Win!</h2>\n            <p>High Score: {highScore}</p>\n            <p>Your Score: {currentScore}</p>\n        </div>\n    );\n  };\n\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)', // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n\n  function Board() {\n\n    let boardSize = Math.sqrt(playerSquares.length);\n\n    function handleClick(i) {\n      \n      //if the player clicks after winning or on an unmovable tile nothing happens\n      if (calculateWinner(playerSquares) || !isMovable(i, playerSquares)){ return; }  //play an error noise\n    \n      clickSound.play();\n\n      setCount(count + 1);\n      const currentScore = count + 1;\n      \n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n\n      if(calculateWinner(nextPlayerSquares)){ \n        if (highScore == 0){ setHighScore(currentScore) }\n        else if(currentScore < highScore) { setHighScore(currentScore) }\n      }\n\n      return;\n\n    }\n\n    /*function botMakesMove(){\n\n     // console.log(\"exploredNodes\", exploredNodes)\n      //let frontier = [exploredNodes[0].slice()];\n\n     // console.log(\"frontier at move start\", frontier);\n\n     // let explored = exploredNodes.slice();\n   //   let destination = [];\n\n      // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n\n      //for(let i = 1; i <= 2; i++){\n        //frontier = explore(frontier, explored, count + i);\n      //}\n    \n      //console.log(\"frontier before sort\", frontier);\n\n//      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n      \n      //console.log(\"frontier after sort\", frontier);\n\n  //    destination = frontier[0];\n\n    //  let nextNode = null;\n\n      //console.log(\"botSquares\", botSquares);\n      //console.log(\"explored[0][0]\", explored[0][0]);\n\n      //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n\n      for(let i = destination[1]; i > explored[0][1] + 1; i--){\n        console.log(\"destination\", destination);                                         \n        nextNode = destination[2];  //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode); \n        destination = nextNode;     //and repeats til it's making only 1 move\n      }\n\n      exploredNodes.unshift(nextNode);\n\n      return nextNode[0];\n      old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n\n      while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */\n    \n    const renderBoard = () => {\n      \n      const board = [];\n\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n      }\n\n      //if(isPlayer){\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n        //}\n      }\n                //Version 2 stuff\n      /*\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */\n      \n      return board;\n    }\n   \n    return (<div className=\"slide-puzzle-board\">{renderBoard()}\n    {calculateWinner(playerSquares) && \n    <Overlay highScore={highScore} currentScore={count} />}\n    </div>);\n  }\n\n  const handleSizeChange = (event) => {\n    let newBoardSize = Number(event.target.value)\n    if(newBoardSize > 10 || newBoardSize < 2){\n      setStatus(\"Please choose a size between 2 and 10!\");\n    }\n    else{\n      restart();\n      setBoardSize(newBoardSize);\n      setStatus(null);\n      let newSquares = initialSetup(newBoardSize);\n      setPlayerSquares(newSquares);\n     // setBotSquares(newSquares);\n      setHistory([[newSquares],[null]]);\n    }\n  };\n  \n  function undo() {\n    if(calculateWinner(playerSquares)){ setStatus(null); }\n    if(history[0].length > 1){\n      console.log(\"undo\");\n      const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n      setHistory(lastHistory);\n      setCount(count - 1);\n      setPlayerSquares(lastHistory[0][count - 1]);\n    //  setBotSquares(lastHistory[1][count - 1]);  \n    } \n    else{setStatus(\"No moves to undo!\");}   \n  }\n  \n  function newShuffle(){\n    console.log(\"shuffle\");\n    restart();\n    shuffle(playerSquares);\n    setPlayerSquares(playerSquares);\n  //  setBotSquares(playerSquares);\n    setHistory([[playerSquares], [playerSquares]]);\n  }\n  \n  function restart(){\n    console.log(\"restart\");\n    while( history[0].length > 1 ){ \n      history[0].pop(); history[1].pop(); } \n    setHistory([history[0], history[0] ]);\n    setPlayerSquares(history[0][0]);\n//    setBotSquares(history[1][0]);\n    setCount(0);\n    setStatus(null);\n  }\n\n  return(\n    <div className='slider-puzzle'>\n      <input className='input' type=\"number\" defaultValue={boardSize} \n      onChange={handleSizeChange} min=\"2\" max=\"10\"/>\n\n      <div className=\"status\">{status}</div> \n      <div className=\"count\">Moves: {count}</div>\n      <div>\n          <>{Board()}</>\n      </div>\n      <div>\n        <button className=\"button\" onClick={() => undo()}>{\"Undo\"}</button>\n        <button className=\"button\" onClick={() => restart()}>{\"Restart\"}</button>\n      </div>\n      <button className=\"button\" onClick={() => newShuffle()}>{\"Shuffle\"}</button>\n    </div>\n  )\n}\n\nexport default SliderPuzzle;\n\n/*\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for(let j = 0; j < startingLength; j++){ \n\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n\n    for(let i = 0; i < movableSquares.length; i++){\n\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if(frontier[0][2] == null){\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if(!hasBeenExplored(nextSquares, explored)){\n          console.log(\"this node has not been explored\");\n          frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n        //else => it has been explored so we dont add it\n    }\n\n    explored.push(frontier[j]);\n\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for(let k = 0; k < frontier.length; k++){\n    if(frontier[k][1] < stepCost){\n      frontier.splice(k, 1);\n      k--;  //this accounts for the removal making sure to check the same index agian \n    }\n  }\n\n  console.log(\"frontier in explore loop\", frontier);\n\n  return frontier;\n\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n\n  for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n\n    if(scores[i] > scores[i + 1]){\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n  //  console.log(\"temp2\", temp2);\n\n    scores[i] = scores[i + 1];\n    scores[i + 1] = temp1;\n\n    //console.log(i);\n\n    //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n    //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n    nodesToExplore[i] = nodesToExplore[i + 1];\n    nodesToExplore[i + 1] = temp2;\n\n      \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n    \n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n\n  }\n\n // console.log(\"scores after sort\", scores);\n // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n\n  for (let i = 0; i < exploredNodes.length; i++){\n\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n\n    if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n      return true;\n    }\n    return false;\n  }\n\n}\n\nfunction getManhattanDistances(squares){\n\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n\n  for (let i = 0; i < squares.length; i++){\n    let j = squares[i] - 1;\n    if(squares[i] == null){\n      j = squares.length - 1;\n    }\n\n    let startingRow = [Math.floor(i / boardSize)]\n    let startingCol = [i % boardSize]\n    let destinationRow = [Math.floor( j / boardSize)]\n    let destinationCol = [ j % boardSize]\n\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n\n    manhattanDistances.push(colDistance + rowDistance);\n\n  }\n\n // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n // console.log(\"sum\", sum);\n\n  return sum;\n\n}*/\n\nfunction freeSquare(squares){\n  return findValue(squares, null);\n}\n\nfunction findValue(squares, value){\n  \n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for(let i = 0; i < squares.length; i++){\n    if(squares[i] == value)\n      position = i;\n  }\n  return position;\n}\n\nfunction initialSetup(boardSize){\n\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++){   //populate 1 -> 1-n\n    values.push(i)           \n  }\n  values.push(null);           //adds null instead of last number for free square\n  shuffle(values);          \n  return values;\n\n}\n\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    let copy = values[currentIndex]\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n\n  if(!isSolvable(values)){shuffle(values);}\n\n}\n\nfunction isSolvable(values){\n\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0\n  let rowMajorOrder = []\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for(let i = 0; i < values.length; i++){\n    if(values[i] !== null){\n      rowMajorOrder.push(values[i]);\n    }\n    else{ \n      rowOfFreeSquare = Math.floor(i/ boardSize)\n    }\n  }\n\n  //counts inversions\n  for(let i = 0; i < rowMajorOrder.length; i++){\n    for(let j = i + 1; j < rowMajorOrder.length; j++){\n      if(rowMajorOrder[i] > rowMajorOrder[j]){\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0){return true} \n  else if( boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1){return true}\n  else{return false}\n\n}\n\nfunction isMovable(position, squares){\n\n  let movable = findMovableSquares(squares);\n  for(let i = 0; i < movable.length ; i++){\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction findMovableSquares(squares){\n\n  //setup table for movable square recognizing\n  let table = []\n  let boardSize = Math.sqrt(squares.length);\n\n  for (let i = 0; i < boardSize; i++){\n    let row = []\n    for (let j = 0; j < boardSize; j++){\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row)\n  }\n\n  let i = freeSquare(squares);\n  let column = i % boardSize; \n  let row = 0;\n  \n  while(i >= boardSize){\n    row++;\n    i = i - boardSize;\n  }\n  \n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if(column + 1 != boardSize){movableSquares.push(table[row][column + 1])}\n  if(column - 1 != -1){movableSquares.push(table[row][column - 1])}\n  if(row + 1 != boardSize){movableSquares.push(table[row + 1][column])}\n  if(row - 1 != -1){movableSquares.push(table[row - 1][column])}\n\n  return movableSquares;\n\n}\n\nfunction calculateWinner(squares) {\n\n  const winnerCheck = new Array(squares.length - 1).fill(-1);\n  let squaresCopy = squares.slice(0);\n\n  for (let i = 0; i < squares.length - 1; i++) {\n    if(squaresCopy[i] == i + 1){\n      squaresCopy[i] = -1\n    }\n  }\n\n  for(let i = 0; i < squares.length - 1; i++){\n    if (squaresCopy[i] !== winnerCheck[i]) return false;\n  }\n  return true;\n}"],"mappings":"AAAA,OAASA,QAAQ,KAAQ,OAAO,CAChC,MAAO,oBAAoB,QAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,CAAAC,QAAA,IAAAC,SAAA,yBAE3B,KAAM,CAAAC,YAAY,CAAGA,CAAA,GAAM,CAEzB,KAAM,CAACC,SAAS,CAAEC,YAAY,CAAC,CAAGT,QAAQ,CAAC,CAAC,CAAC,CAAG;AAChD,KAAM,CAACU,KAAK,CAAEC,QAAQ,CAAC,CAAGX,QAAQ,CAAC,CAAC,CAAC,CACrC,KAAM,CAAAY,eAAe,CAAGC,YAAY,CAACL,SAAS,CAAC,CAC/C,KAAM,CAACM,aAAa,CAAEC,gBAAgB,CAAC,CAAGf,QAAQ,CAACY,eAAe,CAAC,CACnE;AACA,KAAM,CAACI,OAAO,CAAEC,UAAU,CAAC,CAAGjB,QAAQ,CAAC,CAAE,CAAEY,eAAe,CAAE,CAAE,CAAE,IAAI,CAAE,CAAE,CAAC,CACzE,KAAK,CAACM,MAAM,CAAEC,SAAS,CAAC,CAAGnB,QAAQ,CAAC,IAAI,CAAC,CACzC,KAAK,CAACoB,SAAS,CAAEC,YAAY,CAAC,CAAGrB,QAAQ,CAAC,CAAC,CAAC,CAC7C;AACA;AACC,KAAM,CAAAsB,UAAU,CAAG,GAAI,CAAAC,KAAK,CAAC,cAAc,CAAC,CAE5C,QAAS,CAAAC,MAAMA,CAAAC,IAAA,CAA2B,IAA1B,CAAEC,KAAK,CAAEC,aAAc,CAAC,CAAAF,IAAA,CACtC,mBACEvB,IAAA,WAAQ0B,SAAS,CAAC,QAAQ,CAACC,OAAO,CAAEF,aAAc,CAAAG,QAAA,CAC/CJ,KAAK,CACA,CAAC,CAEb,CAEA;AACA;AACAK,OAAO,CAACC,GAAG,CAAC,OAAO,CAAEtB,KAAK,CAAC,CAC3B;AAEA,KAAM,CAAAuB,OAAO,CAAGC,KAAA,EAAiC,IAAhC,CAAEd,SAAS,CAAEe,YAAa,CAAC,CAAAD,KAAA,CAC1C,mBACI9B,KAAA,QAAKgC,KAAK,CAAEC,YAAa,CAAAP,QAAA,eACrB5B,IAAA,OAAA4B,QAAA,CAAI,UAAQ,CAAI,CAAC,cACjB1B,KAAA,MAAA0B,QAAA,EAAG,cAAY,CAACV,SAAS,EAAI,CAAC,cAC9BhB,KAAA,MAAA0B,QAAA,EAAG,cAAY,CAACK,YAAY,EAAI,CAAC,EAChC,CAAC,CAEZ,CAAC,CAED,KAAM,CAAAE,YAAY,CAAG,CACnBC,QAAQ,CAAE,UAAU,CACpBC,GAAG,CAAE,CAAC,CACNC,IAAI,CAAE,CAAC,CACPC,KAAK,CAAE,MAAM,CACbC,MAAM,CAAE,MAAM,CACdC,eAAe,CAAE,oBAAoB,CAAE;AACvCC,KAAK,CAAE,OAAO,CACdC,OAAO,CAAE,MAAM,CACfC,aAAa,CAAE,QAAQ,CACvBC,cAAc,CAAE,QAAQ,CACxBC,UAAU,CAAE,QAAQ,CACpBC,MAAM,CAAE,IACV,CAAC,CAED,QAAS,CAAAC,KAAKA,CAAA,CAAG,CAEf,GAAI,CAAA1C,SAAS,CAAG2C,IAAI,CAACC,IAAI,CAACtC,aAAa,CAACuC,MAAM,CAAC,CAE/C,QAAS,CAAAC,WAAWA,CAACC,CAAC,CAAE,CAEtB;AACA,GAAIC,eAAe,CAAC1C,aAAa,CAAC,EAAI,CAAC2C,SAAS,CAACF,CAAC,CAAEzC,aAAa,CAAC,CAAC,CAAE,OAAQ,CAAG;AAEhFQ,UAAU,CAACoC,IAAI,CAAC,CAAC,CAEjB/C,QAAQ,CAACD,KAAK,CAAG,CAAC,CAAC,CACnB,KAAM,CAAAyB,YAAY,CAAGzB,KAAK,CAAG,CAAC,CAE9B;AACA;AAEA,GAAI,CAAAiD,iBAAiB,CAAG7C,aAAa,CAAC8C,KAAK,CAAC,CAAC,CAC7CD,iBAAiB,CAACE,UAAU,CAAC/C,aAAa,CAAC,CAAC,CAAGA,aAAa,CAACyC,CAAC,CAAC,CAC/DI,iBAAiB,CAACJ,CAAC,CAAC,CAAG,IAAI,CAC3BxC,gBAAgB,CAAC4C,iBAAiB,CAAC,CAEnC3C,OAAO,CAAC,CAAC,CAAC,CAAC8C,IAAI,CAACH,iBAAiB,CAAC,CAClC3C,OAAO,CAAC,CAAC,CAAC,CAAC8C,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CACvB7C,UAAU,CAAC,CAAC,CAAC,GAAGD,OAAO,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAE9C,GAAGwC,eAAe,CAACG,iBAAiB,CAAC,CAAC,CACpC,GAAIvC,SAAS,EAAI,CAAC,CAAC,CAAEC,YAAY,CAACc,YAAY,CAAC,CAAC,CAAC,IAC5C,IAAGA,YAAY,CAAGf,SAAS,CAAE,CAAEC,YAAY,CAACc,YAAY,CAAC,CAAC,CACjE,CAEA,OAEF,CAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAEI,KAAM,CAAA4B,WAAW,CAAGA,CAAA,GAAM,CAExB,KAAM,CAAAC,KAAK,CAAG,EAAE,CAEhB,IAAK,GAAI,CAAAT,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG/C,SAAS,CAAE+C,CAAC,EAAE,CAAC,CACjC,KAAM,CAAAU,GAAG,CAAG,EAAE,CACd,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG1D,SAAS,CAAE0D,CAAC,EAAE,CAAC,CACjC,KAAM,CAAAC,KAAK,CAAG3D,SAAS,CAAG+C,CAAC,CAAGW,CAAC,CAC/BD,GAAG,CAACH,IAAI,cACN5D,IAAA,CAACsB,MAAM,EAELE,KAAK,CAAEZ,aAAa,CAACqD,KAAK,CAAE,CAC5BxC,aAAa,CAAEA,CAAA,GAAM2B,WAAW,CAACa,KAAK,CAAE,EAFnCA,KAGN,CACH,CAAC,CACH,CACAH,KAAK,CAACF,IAAI,cACR5D,IAAA,QAAa0B,SAAS,CAAC,WAAW,CAAAE,QAAA,CAAEmC,GAAG,EAA7BV,CAAmC,CAC/C,CAAC,CACH,CAEA;AACA,IAAK,GAAI,CAAAA,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG/C,SAAS,CAAE+C,CAAC,EAAE,CAAC,CACjC,KAAM,CAAAU,GAAG,CAAG,EAAE,CACd,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG1D,SAAS,CAAE0D,CAAC,EAAE,CAAC,CACjC,KAAM,CAAAC,KAAK,CAAG3D,SAAS,CAAG+C,CAAC,CAAGW,CAAC,CAC/BD,GAAG,CAACH,IAAI,cACN5D,IAAA,CAACsB,MAAM,EAELE,KAAK,CAAEZ,aAAa,CAACqD,KAAK,CAAE,CAC5BxC,aAAa,CAAEA,CAAA,GAAM2B,WAAW,CAACa,KAAK,CAAE,EAFnCA,KAGN,CACH,CAAC,CACH,CACAH,KAAK,CAACF,IAAI,cACR5D,IAAA,QAAa0B,SAAS,CAAC,WAAW,CAAAE,QAAA,CAAEmC,GAAG,EAA7BV,CAAmC,CAC/C,CAAC,CACD;AACF,CACU;AACV;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAEM,MAAO,CAAAS,KAAK,CACd,CAAC,CAED,mBAAQ5D,KAAA,QAAKwB,SAAS,CAAC,oBAAoB,CAAAE,QAAA,EAAEiC,WAAW,CAAC,CAAC,CACzDP,eAAe,CAAC1C,aAAa,CAAC,eAC/BZ,IAAA,CAAC+B,OAAO,EAACb,SAAS,CAAEA,SAAU,CAACe,YAAY,CAAEzB,KAAM,CAAE,CAAC,EACjD,CAAC,CACR,CAEA,KAAM,CAAA0D,gBAAgB,CAAIC,KAAK,EAAK,CAClC,GAAI,CAAAC,YAAY,CAAGC,MAAM,CAACF,KAAK,CAACG,MAAM,CAAC9C,KAAK,CAAC,CAC7C,GAAG4C,YAAY,CAAG,EAAE,EAAIA,YAAY,CAAG,CAAC,CAAC,CACvCnD,SAAS,CAAC,wCAAwC,CAAC,CACrD,CAAC,IACG,CACFsD,OAAO,CAAC,CAAC,CACThE,YAAY,CAAC6D,YAAY,CAAC,CAC1BnD,SAAS,CAAC,IAAI,CAAC,CACf,GAAI,CAAAuD,UAAU,CAAG7D,YAAY,CAACyD,YAAY,CAAC,CAC3CvD,gBAAgB,CAAC2D,UAAU,CAAC,CAC7B;AACCzD,UAAU,CAAC,CAAC,CAACyD,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CACnC,CACF,CAAC,CAED,QAAS,CAAAC,IAAIA,CAAA,CAAG,CACd,GAAGnB,eAAe,CAAC1C,aAAa,CAAC,CAAC,CAAEK,SAAS,CAAC,IAAI,CAAC,CAAE,CACrD,GAAGH,OAAO,CAAC,CAAC,CAAC,CAACqC,MAAM,CAAG,CAAC,CAAC,CACvBtB,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC,CACnB,KAAM,CAAA4C,WAAW,CAAG,CAAC,CAAC,GAAG5D,OAAO,CAAC,CAAC,CAAC,CAAC4C,KAAK,CAAC,CAAC,CAAElD,KAAK,CAAC,CAAC,CAAE,CAAC,GAAGM,OAAO,CAAC,CAAC,CAAC,CAAC4C,KAAK,CAAC,CAAC,CAAElD,KAAK,CAAC,CAAC,CAAC,CACtFO,UAAU,CAAC2D,WAAW,CAAC,CACvBjE,QAAQ,CAACD,KAAK,CAAG,CAAC,CAAC,CACnBK,gBAAgB,CAAC6D,WAAW,CAAC,CAAC,CAAC,CAAClE,KAAK,CAAG,CAAC,CAAC,CAAC,CAC7C;AACA,CAAC,IACG,CAACS,SAAS,CAAC,mBAAmB,CAAC,CAAC,CACtC,CAEA,QAAS,CAAA0D,UAAUA,CAAA,CAAE,CACnB9C,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC,CACtByC,OAAO,CAAC,CAAC,CACTK,OAAO,CAAChE,aAAa,CAAC,CACtBC,gBAAgB,CAACD,aAAa,CAAC,CACjC;AACEG,UAAU,CAAC,CAAC,CAACH,aAAa,CAAC,CAAE,CAACA,aAAa,CAAC,CAAC,CAAC,CAChD,CAEA,QAAS,CAAA2D,OAAOA,CAAA,CAAE,CAChB1C,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC,CACtB,MAAOhB,OAAO,CAAC,CAAC,CAAC,CAACqC,MAAM,CAAG,CAAC,CAAE,CAC5BrC,OAAO,CAAC,CAAC,CAAC,CAAC+D,GAAG,CAAC,CAAC,CAAE/D,OAAO,CAAC,CAAC,CAAC,CAAC+D,GAAG,CAAC,CAAC,CAAE,CACtC9D,UAAU,CAAC,CAACD,OAAO,CAAC,CAAC,CAAC,CAAEA,OAAO,CAAC,CAAC,CAAC,CAAE,CAAC,CACrCD,gBAAgB,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnC;AACIL,QAAQ,CAAC,CAAC,CAAC,CACXQ,SAAS,CAAC,IAAI,CAAC,CACjB,CAEA,mBACEf,KAAA,QAAKwB,SAAS,CAAC,eAAe,CAAAE,QAAA,eAC5B5B,IAAA,UAAO0B,SAAS,CAAC,OAAO,CAACoD,IAAI,CAAC,QAAQ,CAACC,YAAY,CAAEzE,SAAU,CAC/D0E,QAAQ,CAAEd,gBAAiB,CAACe,GAAG,CAAC,GAAG,CAACC,GAAG,CAAC,IAAI,CAAC,CAAC,cAE9ClF,IAAA,QAAK0B,SAAS,CAAC,QAAQ,CAAAE,QAAA,CAAEZ,MAAM,CAAM,CAAC,cACtCd,KAAA,QAAKwB,SAAS,CAAC,OAAO,CAAAE,QAAA,EAAC,SAAO,CAACpB,KAAK,EAAM,CAAC,cAC3CR,IAAA,QAAA4B,QAAA,cACI5B,IAAA,CAAAI,SAAA,EAAAwB,QAAA,CAAGoB,KAAK,CAAC,CAAC,CAAG,CAAC,CACb,CAAC,cACN9C,KAAA,QAAA0B,QAAA,eACE5B,IAAA,WAAQ0B,SAAS,CAAC,QAAQ,CAACC,OAAO,CAAEA,CAAA,GAAM8C,IAAI,CAAC,CAAE,CAAA7C,QAAA,CAAE,MAAM,CAAS,CAAC,cACnE5B,IAAA,WAAQ0B,SAAS,CAAC,QAAQ,CAACC,OAAO,CAAEA,CAAA,GAAM4C,OAAO,CAAC,CAAE,CAAA3C,QAAA,CAAE,SAAS,CAAS,CAAC,EACtE,CAAC,cACN5B,IAAA,WAAQ0B,SAAS,CAAC,QAAQ,CAACC,OAAO,CAAEA,CAAA,GAAMgD,UAAU,CAAC,CAAE,CAAA/C,QAAA,CAAE,SAAS,CAAS,CAAC,EACzE,CAAC,CAEV,CAAC,CAED,cAAe,CAAAvB,YAAY,CAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA,QAAS,CAAAsD,UAAUA,CAACwB,OAAO,CAAC,CAC1B,MAAO,CAAAC,SAAS,CAACD,OAAO,CAAE,IAAI,CAAC,CACjC,CAEA,QAAS,CAAAC,SAASA,CAACD,OAAO,CAAE3D,KAAK,CAAC,CAEhC;AACA;AACA,GAAI,CAAAY,QAAQ,CAAG,IAAI,CACnB,IAAI,GAAI,CAAAiB,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG8B,OAAO,CAAChC,MAAM,CAAEE,CAAC,EAAE,CAAC,CACrC,GAAG8B,OAAO,CAAC9B,CAAC,CAAC,EAAI7B,KAAK,CACpBY,QAAQ,CAAGiB,CAAC,CAChB,CACA,MAAO,CAAAjB,QAAQ,CACjB,CAEA,QAAS,CAAAzB,YAAYA,CAACL,SAAS,CAAC,CAE9B,GAAI,CAAA+E,MAAM,CAAG,EAAE,CACf,IAAK,GAAI,CAAAhC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG/C,SAAS,EAAI,CAAC,CAAE+C,CAAC,EAAE,CAAC,CAAI;AAC1CgC,MAAM,CAACzB,IAAI,CAACP,CAAC,CAAC,CAChB,CACAgC,MAAM,CAACzB,IAAI,CAAC,IAAI,CAAC,CAAY;AAC7BgB,OAAO,CAACS,MAAM,CAAC,CACf,MAAO,CAAAA,MAAM,C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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}