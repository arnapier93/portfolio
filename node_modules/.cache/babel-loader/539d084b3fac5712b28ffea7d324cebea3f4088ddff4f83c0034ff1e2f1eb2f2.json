{"ast":null,"code":"var _jsxFileName = \"C:\\\\portfolio\\\\src\\\\components\\\\SliderPuzzle.js\",\n  _s = $RefreshSig$();\nimport { useState } from 'react';\nimport \"./SliderPuzzle.css\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst SliderPuzzle = () => {\n  _s();\n  const [boardSize, setBoardSize] = useState(3); //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([[startingSquares], [null]]);\n  const [status, setStatus] = useState(null);\n  const [highScore, setHighScore] = useState(0);\n  // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n  // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n  function Square({\n    value,\n    onSquareClick\n  }) {\n    return /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"square\",\n      onClick: onSquareClick,\n      children: value\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 7\n    }, this);\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({\n    highScore,\n    currentScore\n  }) => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: overlayStyle,\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"You Win!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"High Score: \", highScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 35,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Your Score: \", currentScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 36,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 9\n    }, this);\n  };\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)',\n    // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n  function Board() {\n    let boardSize = Math.sqrt(playerSquares.length);\n    function handleClick(i) {\n      //if the player clicks after winning or on an unmovable tile nothing happens\n      if (calculateWinner(playerSquares) || !isMovable(i, playerSquares)) {\n        return;\n      } //play an error noise\n\n      clickSound.play();\n      setCount(count + 1);\n      const currentScore = count + 1;\n\n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n      if (calculateWinner(nextPlayerSquares)) {\n        if (highScore == 0) {\n          setHighScore(currentScore);\n        } else if (currentScore < highScore) {\n          setHighScore(currentScore);\n        }\n      }\n      return;\n    }\n\n    /*function botMakesMove(){\n      // console.log(\"exploredNodes\", exploredNodes)\n      //let frontier = [exploredNodes[0].slice()];\n      // console.log(\"frontier at move start\", frontier);\n      // let explored = exploredNodes.slice();\n    //   let destination = [];\n       // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n       //for(let i = 1; i <= 2; i++){\n        //frontier = explore(frontier, explored, count + i);\n      //}\n    \n      //console.log(\"frontier before sort\", frontier);\n    //      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n      \n      //console.log(\"frontier after sort\", frontier);\n    //    destination = frontier[0];\n     //  let nextNode = null;\n       //console.log(\"botSquares\", botSquares);\n      //console.log(\"explored[0][0]\", explored[0][0]);\n       //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n       for(let i = destination[1]; i > explored[0][1] + 1; i--){\n        console.log(\"destination\", destination);                                         \n        nextNode = destination[2];  //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode); \n        destination = nextNode;     //and repeats til it's making only 1 move\n      }\n       exploredNodes.unshift(nextNode);\n       return nextNode[0];\n      old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n       while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */\n\n    const renderBoard = () => {\n      const board = [];\n      for (let i = 0; i < boardSize; i++) {\n        const row = [];\n        for (let j = 0; j < boardSize; j++) {\n          const index = boardSize * i + j;\n          row.push(/*#__PURE__*/_jsxDEV(Square, {\n            value: playerSquares[index],\n            onSquareClick: () => handleClick(index)\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 163,\n            columnNumber: 13\n          }, this));\n        }\n        board.push(/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"board-row\",\n          children: row\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 171,\n          columnNumber: 11\n        }, this));\n      }\n\n      //if(isPlayer){\n      for (let i = 0; i < boardSize; i++) {\n        const row = [];\n        for (let j = 0; j < boardSize; j++) {\n          const index = boardSize * i + j;\n          row.push(/*#__PURE__*/_jsxDEV(Square, {\n            value: playerSquares[index],\n            onSquareClick: () => handleClick(index)\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 181,\n            columnNumber: 13\n          }, this));\n        }\n        board.push(/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"board-row\",\n          children: row\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 189,\n          columnNumber: 11\n        }, this));\n        //}\n      }\n      //Version 2 stuff\n      /*\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */\n\n      return board;\n    };\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"slide-puzzle-board\",\n      children: [renderBoard(), calculateWinner(playerSquares) && /*#__PURE__*/_jsxDEV(Overlay, {\n        highScore: highScore,\n        currentScore: count\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 221,\n        columnNumber: 5\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 13\n    }, this);\n  }\n  const handleSizeChange = event => {\n    let newBoardSize = Number(event.target.value);\n    if (newBoardSize > 10 || newBoardSize < 2) {\n      setStatus(\"Please choose a size between 2 and 10!\");\n    } else {\n      restart();\n      setBoardSize(newBoardSize);\n      setStatus(null);\n      let newSquares = initialSetup(newBoardSize);\n      setPlayerSquares(newSquares);\n      // setBotSquares(newSquares);\n      setHistory([[newSquares], [null]]);\n    }\n  };\n  function undo() {\n    if (calculateWinner(playerSquares)) {\n      setStatus(null);\n    }\n    if (history[0].length > 1) {\n      console.log(\"undo\");\n      const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n      setHistory(lastHistory);\n      setCount(count - 1);\n      setPlayerSquares(lastHistory[0][count - 1]);\n      //  setBotSquares(lastHistory[1][count - 1]);  \n    } else {\n      setStatus(\"No moves to undo!\");\n    }\n  }\n  function newShuffle() {\n    console.log(\"shuffle\");\n    restart();\n    shuffle(playerSquares);\n    setPlayerSquares(playerSquares);\n    //  setBotSquares(playerSquares);\n    setHistory([[playerSquares], [playerSquares]]);\n  }\n  function restart() {\n    console.log(\"restart\");\n    while (history[0].length > 1) {\n      history[0].pop();\n      history[1].pop();\n    }\n    setHistory([history[0], history[0]]);\n    setPlayerSquares(history[0][0]);\n    //    setBotSquares(history[1][0]);\n    setCount(0);\n    setStatus(null);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"slider-puzzle\",\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      className: \"input\",\n      type: \"number\",\n      defaultValue: boardSize,\n      onChange: handleSizeChange,\n      min: \"2\",\n      max: \"10\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 276,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status\",\n      children: status\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 279,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"count\",\n      children: [\"Moves: \", count]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 280,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: Board()\n      }, void 0, false)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"button\",\n        onClick: () => undo(),\n        children: \"Undo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 285,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"button\",\n        onClick: () => restart(),\n        children: \"Restart\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 286,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 284,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"button\",\n      onClick: () => newShuffle(),\n      children: \"Shuffle\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 288,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 275,\n    columnNumber: 5\n  }, this);\n};\n_s(SliderPuzzle, \"KYoqtXFlLocuDXsMHGsMLk2F0hQ=\");\n_c = SliderPuzzle;\nexport default SliderPuzzle;\n\n/*\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for(let j = 0; j < startingLength; j++){ \n\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n\n    for(let i = 0; i < movableSquares.length; i++){\n\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if(frontier[0][2] == null){\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if(!hasBeenExplored(nextSquares, explored)){\n          console.log(\"this node has not been explored\");\n          frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n        //else => it has been explored so we dont add it\n    }\n\n    explored.push(frontier[j]);\n\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for(let k = 0; k < frontier.length; k++){\n    if(frontier[k][1] < stepCost){\n      frontier.splice(k, 1);\n      k--;  //this accounts for the removal making sure to check the same index agian \n    }\n  }\n\n  console.log(\"frontier in explore loop\", frontier);\n\n  return frontier;\n\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n\n  for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n\n    if(scores[i] > scores[i + 1]){\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n  //  console.log(\"temp2\", temp2);\n\n    scores[i] = scores[i + 1];\n    scores[i + 1] = temp1;\n\n    //console.log(i);\n\n    //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n    //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n    nodesToExplore[i] = nodesToExplore[i + 1];\n    nodesToExplore[i + 1] = temp2;\n\n      \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n    \n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n\n  }\n\n // console.log(\"scores after sort\", scores);\n // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n\n  for (let i = 0; i < exploredNodes.length; i++){\n\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n\n    if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n      return true;\n    }\n    return false;\n  }\n\n}\n\nfunction getManhattanDistances(squares){\n\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n\n  for (let i = 0; i < squares.length; i++){\n    let j = squares[i] - 1;\n    if(squares[i] == null){\n      j = squares.length - 1;\n    }\n\n    let startingRow = [Math.floor(i / boardSize)]\n    let startingCol = [i % boardSize]\n    let destinationRow = [Math.floor( j / boardSize)]\n    let destinationCol = [ j % boardSize]\n\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n\n    manhattanDistances.push(colDistance + rowDistance);\n\n  }\n\n // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n // console.log(\"sum\", sum);\n\n  return sum;\n\n}*/\n\nfunction freeSquare(squares) {\n  return findValue(squares, null);\n}\nfunction findValue(squares, value) {\n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for (let i = 0; i < squares.length; i++) {\n    if (squares[i] == value) position = i;\n  }\n  return position;\n}\nfunction initialSetup(boardSize) {\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++) {\n    //populate 1 -> 1-n\n    values.push(i);\n  }\n  values.push(null); //adds null instead of last number for free square\n  shuffle(values);\n  return values;\n}\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    let copy = values[currentIndex];\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n  if (!isSolvable(values)) {\n    shuffle(values);\n  }\n}\nfunction isSolvable(values) {\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0;\n  let rowMajorOrder = [];\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      rowMajorOrder.push(values[i]);\n    } else {\n      rowOfFreeSquare = Math.floor(i / boardSize);\n    }\n  }\n\n  //counts inversions\n  for (let i = 0; i < rowMajorOrder.length; i++) {\n    for (let j = i + 1; j < rowMajorOrder.length; j++) {\n      if (rowMajorOrder[i] > rowMajorOrder[j]) {\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0) {\n    return true;\n  } else if (boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isMovable(position, squares) {\n  let movable = findMovableSquares(squares);\n  for (let i = 0; i < movable.length; i++) {\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction findMovableSquares(squares) {\n  //setup table for movable square recognizing\n  let table = [];\n  let boardSize = Math.sqrt(squares.length);\n  for (let i = 0; i < boardSize; i++) {\n    let row = [];\n    for (let j = 0; j < boardSize; j++) {\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row);\n  }\n  let i = freeSquare(squares);\n  let column = i % boardSize;\n  let row = 0;\n  while (i >= boardSize) {\n    row++;\n    i = i - boardSize;\n  }\n\n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if (column + 1 != boardSize) {\n    movableSquares.push(table[row][column + 1]);\n  }\n  if (column - 1 != -1) {\n    movableSquares.push(table[row][column - 1]);\n  }\n  if (row + 1 != boardSize) {\n    movableSquares.push(table[row + 1][column]);\n  }\n  if (row - 1 != -1) {\n    movableSquares.push(table[row - 1][column]);\n  }\n  return movableSquares;\n}\nfunction calculateWinner(squares) {\n  const winnerCheck = new Array(squares.length - 1).fill(-1);\n  let squaresCopy = squares.slice(0);\n  for (let i = 0; i < squares.length - 1; i++) {\n    if (squaresCopy[i] == i + 1) {\n      squaresCopy[i] = -1;\n    }\n  }\n  for (let i = 0; i < squares.length - 1; i++) {\n    if (squaresCopy[i] !== winnerCheck[i]) return false;\n  }\n  return true;\n}\nvar _c;\n$RefreshReg$(_c, \"SliderPuzzle\");","map":{"version":3,"names":["useState","jsxDEV","_jsxDEV","Fragment","_Fragment","SliderPuzzle","_s","boardSize","setBoardSize","count","setCount","startingSquares","initialSetup","playerSquares","setPlayerSquares","history","setHistory","status","setStatus","highScore","setHighScore","clickSound","Audio","Square","value","onSquareClick","className","onClick","children","fileName","_jsxFileName","lineNumber","columnNumber","console","log","Overlay","currentScore","style","overlayStyle","position","top","left","width","height","backgroundColor","color","display","flexDirection","justifyContent","alignItems","zIndex","Board","Math","sqrt","length","handleClick","i","calculateWinner","isMovable","play","nextPlayerSquares","slice","freeSquare","push","renderBoard","board","row","j","index","handleSizeChange","event","newBoardSize","Number","target","restart","newSquares","undo","lastHistory","newShuffle","shuffle","pop","type","defaultValue","onChange","min","max","_c","squares","findValue","values","currentIndex","randomIndex","floor","random","copy","isSolvable","inversions","rowMajorOrder","rowOfFreeSquare","movable","findMovableSquares","table","column","movableSquares","winnerCheck","Array","fill","squaresCopy","$RefreshReg$"],"sources":["C:/portfolio/src/components/SliderPuzzle.js"],"sourcesContent":["import { useState } from 'react';\nimport \"./SliderPuzzle.css\"\n\nconst SliderPuzzle = () => {\n\n  const [boardSize, setBoardSize] = useState(3);  //defaults to 3\n  const [count, setCount] = useState(0);\n  const startingSquares = initialSetup(boardSize);\n  const [playerSquares, setPlayerSquares] = useState(startingSquares);\n  //const [botSquares, setBotSquares] = useState(startingSquares);\n  const [history, setHistory] = useState([ [ startingSquares ], [ null ] ]);\n  const[status, setStatus] = useState(null);\n  const[highScore, setHighScore] = useState(0);\n // const[frontier, setFrontier] = useState([[startingSquares, count, null]]);\n // const[exploredNodes, setExploredNodes] = useState( [ [startingSquares, 0/*score -- count + manhattanSquares*/, null] ] );\n  const clickSound = new Audio('../click.ogg');\n\n  function Square({ value, onSquareClick }) {\n    return (\n      <button className=\"square\" onClick={onSquareClick}>\n        {value}\n      </button>\n    );\n  }\n\n  //console.log(\"history\", history);\n  //console.log(\"frontier\", frontier);\n  console.log(\"count\", count);\n  //console.log(\"exlporeNodes\", exploredNodes);\n\n  const Overlay = ({ highScore, currentScore }) => {\n    return (\n        <div style={overlayStyle}>\n            <h2>You Win!</h2>\n            <p>High Score: {highScore}</p>\n            <p>Your Score: {currentScore}</p>\n        </div>\n    );\n  };\n\n  const overlayStyle = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)', // Semi-transparent black\n    color: 'white',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000\n  };\n\n  function Board() {\n\n    let boardSize = Math.sqrt(playerSquares.length);\n\n    function handleClick(i) {\n      \n      //if the player clicks after winning or on an unmovable tile nothing happens\n      if (calculateWinner(playerSquares) || !isMovable(i, playerSquares)){ return; }  //play an error noise\n    \n      clickSound.play();\n\n      setCount(count + 1);\n      const currentScore = count + 1;\n      \n      //let nextBotSquares = botMakesMove();\n      //setBotSquares(nextBotSquares);      \n\n      let nextPlayerSquares = playerSquares.slice();\n      nextPlayerSquares[freeSquare(playerSquares)] = playerSquares[i];\n      nextPlayerSquares[i] = null;\n      setPlayerSquares(nextPlayerSquares);\n\n      history[0].push(nextPlayerSquares);\n      history[1].push([null]);\n      setHistory([[...history[0]], [...history[1]]]);\n\n      if(calculateWinner(nextPlayerSquares)){ \n        if (highScore == 0){ setHighScore(currentScore) }\n        else if(currentScore < highScore) { setHighScore(currentScore) }\n      }\n\n      return;\n\n    }\n\n    /*function botMakesMove(){\n\n     // console.log(\"exploredNodes\", exploredNodes)\n      //let frontier = [exploredNodes[0].slice()];\n\n     // console.log(\"frontier at move start\", frontier);\n\n     // let explored = exploredNodes.slice();\n   //   let destination = [];\n\n      // explore every node for x layers and pick the best\n      // node based on manhattanSquares, then trace back that\n      // node to the parent node at the level of the next move\n      // then make the move\n\n      //for(let i = 1; i <= 2; i++){\n        //frontier = explore(frontier, explored, count + i);\n      //}\n    \n      //console.log(\"frontier before sort\", frontier);\n\n//      frontier = sortByCost(frontier);\n      //add the first element to the explored list\n      \n      //console.log(\"frontier after sort\", frontier);\n\n  //    destination = frontier[0];\n\n    //  let nextNode = null;\n\n      //console.log(\"botSquares\", botSquares);\n      //console.log(\"explored[0][0]\", explored[0][0]);\n\n      //console.log(\"destination\", destination);\n      //console.log(\"destination 1\", destination[1]);\n\n      for(let i = destination[1]; i > explored[0][1] + 1; i--){\n        console.log(\"destination\", destination);                                         \n        nextNode = destination[2];  //gets the previous board to the desination     \n        console.log(\"nextNode\", nextNode); \n        destination = nextNode;     //and repeats til it's making only 1 move\n      }\n\n      exploredNodes.unshift(nextNode);\n\n      return nextNode[0];\n      old version -- randomly chooses tile to move\n      let moveFound = false;\n      let index = null;\n\n      while(!moveFound){\n        index = Math.floor(Math.random() * boardSize) //this seems like its probably wrong\n        if(isMovable(index, botSquares)){\n          let nextSquares = botSquares.slice();\n          nextSquares[freeSquare(botSquares)] = botSquares[index];\n          nextSquares[index] = null;\n          setBotSquares(nextSquares);\n          moveFound = true;\n          return nextSquares;\n        }\n      }\n      */\n    \n    const renderBoard = () => {\n      \n      const board = [];\n\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n      }\n\n      //if(isPlayer){\n      for (let i = 0; i < boardSize; i++){\n        const row = [];\n        for (let j = 0; j < boardSize; j++){\n          const index = boardSize * i + j;\n          row.push(\n            <Square\n              key={index}\n              value={playerSquares[index]} \n              onSquareClick={() => handleClick(index)} \n            />\n          );\n        }\n        board.push(\n          <div key={i} className=\"board-row\">{row}</div>\n        );          \n        //}\n      }\n                //Version 2 stuff\n      /*\n      else{\n        console.log(\"botSquares\", botSquares);\n        for (let i = 0; i < boardSize; i++){\n          const row = [];\n          for (let j = 0; j < boardSize; j++){\n            const index = boardSize * i + j;\n            row.push(\n              <Square\n                key={index}\n                value={botSquares[index]} \n                onSquareClick={() => handleClick(index)} \n              />\n            );\n          }\n          board.push(\n            <div key={i} className=\"board-row\">{row}</div>\n          );          \n        }\n      }\n      */\n      \n      return board;\n    }\n   \n    return (<div className=\"slide-puzzle-board\">{renderBoard()}\n    {calculateWinner(playerSquares) && \n    <Overlay highScore={highScore} currentScore={count} />}\n    </div>);\n  }\n\n  const handleSizeChange = (event) => {\n    let newBoardSize = Number(event.target.value)\n    if(newBoardSize > 10 || newBoardSize < 2){\n      setStatus(\"Please choose a size between 2 and 10!\");\n    }\n    else{\n      restart();\n      setBoardSize(newBoardSize);\n      setStatus(null);\n      let newSquares = initialSetup(newBoardSize);\n      setPlayerSquares(newSquares);\n     // setBotSquares(newSquares);\n      setHistory([[newSquares],[null]]);\n    }\n  };\n  \n  function undo() {\n    if(calculateWinner(playerSquares)){ setStatus(null); }\n    if(history[0].length > 1){\n      console.log(\"undo\");\n      const lastHistory = [[...history[0].slice(0, count)], [...history[1].slice(0, count)]];\n      setHistory(lastHistory);\n      setCount(count - 1);\n      setPlayerSquares(lastHistory[0][count - 1]);\n    //  setBotSquares(lastHistory[1][count - 1]);  \n    } \n    else{setStatus(\"No moves to undo!\");}   \n  }\n  \n  function newShuffle(){\n    console.log(\"shuffle\");\n    restart();\n    shuffle(playerSquares);\n    setPlayerSquares(playerSquares);\n  //  setBotSquares(playerSquares);\n    setHistory([[playerSquares], [playerSquares]]);\n  }\n  \n  function restart(){\n    console.log(\"restart\");\n    while( history[0].length > 1 ){ \n      history[0].pop(); history[1].pop(); } \n    setHistory([history[0], history[0] ]);\n    setPlayerSquares(history[0][0]);\n//    setBotSquares(history[1][0]);\n    setCount(0);\n    setStatus(null);\n  }\n\n  return(\n    <div className='slider-puzzle'>\n      <input className='input' type=\"number\" defaultValue={boardSize} \n      onChange={handleSizeChange} min=\"2\" max=\"10\"/>\n\n      <div className=\"status\">{status}</div> \n      <div className=\"count\">Moves: {count}</div>\n      <div>\n          <>{Board()}</>\n      </div>\n      <div>\n        <button className=\"button\" onClick={() => undo()}>{\"Undo\"}</button>\n        <button className=\"button\" onClick={() => restart()}>{\"Restart\"}</button>\n      </div>\n      <button className=\"button\" onClick={() => newShuffle()}>{\"Shuffle\"}</button>\n    </div>\n  )\n}\n\nexport default SliderPuzzle;\n\n/*\nfunction explore(frontier, exploredNodesCopy, stepCost){  //[nodes][nodes][int]\n\n  let explored = exploredNodesCopy.slice();\n\n  //using startingLength keeps it constant, frontier is added to within the loop\n  let startingLength = frontier.length;\n  for(let j = 0; j < startingLength; j++){ \n\n    let squaresToBeExplored = frontier[j][0].slice();\n    //console.log(\"squaresToBeExplored\", squaresToBeExplored);\n    let movableSquares = findMovableSquares(squaresToBeExplored);\n\n    for(let i = 0; i < movableSquares.length; i++){\n\n      let nextSquares = squaresToBeExplored.slice();\n      nextSquares[freeSquare(squaresToBeExplored)] = movableSquares[i];\n      nextSquares[findValue(squaresToBeExplored, movableSquares[i])] = null;\n\n      //special case for first move\n      if(frontier[0][2] == null){\n        console.log(\"this should only ever print once\");\n        frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      } else if(!hasBeenExplored(nextSquares, explored)){\n          console.log(\"this node has not been explored\");\n          frontier.push([nextSquares, stepCost + getManhattanDistances(nextSquares), frontier[j]]);\n      }\n        //else => it has been explored so we dont add it\n    }\n\n    explored.push(frontier[j]);\n\n  }\n\n  //unlike above loop we need the final index to be variable \n  //as we remove items or we will go out of bounds\n  for(let k = 0; k < frontier.length; k++){\n    if(frontier[k][1] < stepCost){\n      frontier.splice(k, 1);\n      k--;  //this accounts for the removal making sure to check the same index agian \n    }\n  }\n\n  console.log(\"frontier in explore loop\", frontier);\n\n  return frontier;\n\n}\n\n/////////need to redo sorting now that the whole score is already included in the node\nfunction sortByCost(frontierCopy){\n\n  //sort the frontier by prioritizing manhattan distances comnbined with count\n  let scores = [];\n  let manhattanDistances = null;\n  let nodesToExplore = frontierCopy.slice();\n\n  for(let i = 0; i < nodesToExplore.length; i++){ //scores them all\n    manhattanDistances = getManhattanDistances(nodesToExplore[i][0]);\n    scores.push(manhattanDistances); // + frontierCopy[i][1]\n  }\n\n  //console.log(\"scores before sort\", scores)\n////////////////////////this is where breakpoints come in handy\n\n  for (let i = 0; i < scores.length; i++){ //sorts frontier based on scores\n\n    if(scores[i] > scores[i + 1]){\n      //swap the elements in the frontiers AND the corresponding scores\n      let temp1 = scores[i];\n      let temp2 = nodesToExplore[i];\n\n  //  console.log(\"temp2\", temp2);\n\n    scores[i] = scores[i + 1];\n    scores[i + 1] = temp1;\n\n    //console.log(i);\n\n    //console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n    //console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n\n    nodesToExplore[i] = nodesToExplore[i + 1];\n    nodesToExplore[i + 1] = temp2;\n\n      \n//    console.log(\"frontierCopy[i]\", nodesToExplore[i]);\n  //  console.log(\"frontierCopy[i+1]\", nodesToExplore[i+1]);\n    \n      //restarts the loop at 0 to start the check over again \n      //each time a change is made\n      i = -1;\n    }\n\n  }\n\n // console.log(\"scores after sort\", scores);\n // console.log(\"frontier copy inside sort function after sorting\", nodesToExplore);\n\n  return nodesToExplore;\n\n}\n\n///this works but i must not be using it right because it doesnt succesfully block repeats\nfunction hasBeenExplored(squares, exploredNodes){\n\n  for (let i = 0; i < exploredNodes.length; i++){\n\n    console.log(\"squares\", squares);\n    console.log(\"exploredNodes[i][0].slice()\", exploredNodes[i][0].slice());\n\n    if(JSON.stringify(squares.slice()) === JSON.stringify(exploredNodes[i][0].slice())){\n      return true;\n    }\n    return false;\n  }\n\n}\n\nfunction getManhattanDistances(squares){\n\n  //note: the square with value 1 is index 0 in \"squares\"\n  let boardSize = Math.sqrt(squares.length);\n  let manhattanDistances = [];\n\n  for (let i = 0; i < squares.length; i++){\n    let j = squares[i] - 1;\n    if(squares[i] == null){\n      j = squares.length - 1;\n    }\n\n    let startingRow = [Math.floor(i / boardSize)]\n    let startingCol = [i % boardSize]\n    let destinationRow = [Math.floor( j / boardSize)]\n    let destinationCol = [ j % boardSize]\n\n    let colDistance = Math.abs(destinationCol - startingCol);\n    let rowDistance = Math.abs(destinationRow - startingRow);\n\n    manhattanDistances.push(colDistance + rowDistance);\n\n  }\n\n // console.log(\"manhattanDistances\", manhattanDistances);\n  let sum = manhattanDistances.reduce((accumulator, current) => accumulator + current);\n // console.log(\"sum\", sum);\n\n  return sum;\n\n}*/\n\nfunction freeSquare(squares){\n  return findValue(squares, null);\n}\n\nfunction findValue(squares, value){\n  \n  //returns position in \"squares\" of the value\n  //console.log(\"squares, value\", squares, value)\n  let position = null;\n  for(let i = 0; i < squares.length; i++){\n    if(squares[i] == value)\n      position = i;\n  }\n  return position;\n}\n\nfunction initialSetup(boardSize){\n\n  let values = [];\n  for (let i = 1; i < boardSize ** 2; i++){   //populate 1 -> 1-n\n    values.push(i)           \n  }\n  values.push(null);           //adds null instead of last number for free square\n  shuffle(values);          \n  return values;\n\n}\n\nfunction shuffle(values) {\n  let currentIndex = values.length;\n  while (currentIndex != 0) {\n\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    let copy = values[currentIndex]\n    values[currentIndex] = values[randomIndex];\n    values[randomIndex] = copy;\n  }\n\n  if(!isSolvable(values)){shuffle(values);}\n\n}\n\nfunction isSolvable(values){\n\n  //for odd numbered boardsizes the # of inversions in the\n  //row major order must be even to be solvable\n  //an inversion is any pair of tiles i and j where i > j \n  //but i appears before j when considering the board in row-major order\n\n  //for even numbered boardsizes it is only solvable if and only if the \n  //number of inversions //plus// the row of the free square is odd.\n\n  //values =  [2, 5, 4, 7, 1, 6, 3, null, 8] \n  //solvable board for debugging 10 inversions\n\n  let inversions = 0\n  let rowMajorOrder = []\n  let rowOfFreeSquare = -1;\n  let boardSize = Math.sqrt(values.length);\n\n  //removes the null\n  for(let i = 0; i < values.length; i++){\n    if(values[i] !== null){\n      rowMajorOrder.push(values[i]);\n    }\n    else{ \n      rowOfFreeSquare = Math.floor(i/ boardSize)\n    }\n  }\n\n  //counts inversions\n  for(let i = 0; i < rowMajorOrder.length; i++){\n    for(let j = i + 1; j < rowMajorOrder.length; j++){\n      if(rowMajorOrder[i] > rowMajorOrder[j]){\n        inversions++;\n      }\n    }\n  }\n\n  //check if its even or not\n  if (boardSize % 2 == 1 && inversions % 2 == 0){return true} \n  else if( boardSize % 2 == 0 && (inversions + rowOfFreeSquare) % 2 == 1){return true}\n  else{return false}\n\n}\n\nfunction isMovable(position, squares){\n\n  let movable = findMovableSquares(squares);\n  for(let i = 0; i < movable.length ; i++){\n    if (movable[i] == squares[position]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction findMovableSquares(squares){\n\n  //setup table for movable square recognizing\n  let table = []\n  let boardSize = Math.sqrt(squares.length);\n\n  for (let i = 0; i < boardSize; i++){\n    let row = []\n    for (let j = 0; j < boardSize; j++){\n      row.push(squares[boardSize * i + j]);\n    }\n    table.push(row)\n  }\n\n  let i = freeSquare(squares);\n  let column = i % boardSize; \n  let row = 0;\n  \n  while(i >= boardSize){\n    row++;\n    i = i - boardSize;\n  }\n  \n  //checks if the index is out of bounds and if not it adds that value to the list\n  let movableSquares = [];\n  if(column + 1 != boardSize){movableSquares.push(table[row][column + 1])}\n  if(column - 1 != -1){movableSquares.push(table[row][column - 1])}\n  if(row + 1 != boardSize){movableSquares.push(table[row + 1][column])}\n  if(row - 1 != -1){movableSquares.push(table[row - 1][column])}\n\n  return movableSquares;\n\n}\n\nfunction calculateWinner(squares) {\n\n  const winnerCheck = new Array(squares.length - 1).fill(-1);\n  let squaresCopy = squares.slice(0);\n\n  for (let i = 0; i < squares.length - 1; i++) {\n    if(squaresCopy[i] == i + 1){\n      squaresCopy[i] = -1\n    }\n  }\n\n  for(let i = 0; i < squares.length - 1; i++){\n    if (squaresCopy[i] !== winnerCheck[i]) return false;\n  }\n  return true;\n}"],"mappings":"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,CAAE;QAAAhD,QAAA,EAAE;MAAM;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAS,CAAC,eACnE9B,OAAA;QAAQwB,SAAS,EAAC,QAAQ;QAACC,OAAO,EAAEA,CAAA,KAAM+C,OAAO,CAAC,CAAE;QAAA9C,QAAA,EAAE;MAAS;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAS,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACtE,CAAC,eACN9B,OAAA;MAAQwB,SAAS,EAAC,QAAQ;MAACC,OAAO,EAAEA,CAAA,KAAMmD,UAAU,CAAC,CAAE;MAAAlD,QAAA,EAAE;IAAS;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAS,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACzE,CAAC;AAEV,CAAC;AAAA1B,EAAA,CA/RKD,YAAY;AAAAiF,EAAA,GAAZjF,YAAY;AAiSlB,eAAeA,YAAY;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}